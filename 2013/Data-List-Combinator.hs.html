<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data-List-Combinator.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><span class='hs-comment'>-- Copyright Â© 2012 Bart Massey</span>
<span class='hs-comment'>-- [This program is licensed under the "BSD License"]</span>
<span class='hs-comment'>-- Please see the file COPYING in the source</span>
<span class='hs-comment'>-- distribution of this software for license terms.</span>

<span class='hs-comment'>-----------------------------------------------------------------------------</span>
<span class='hs-comment'>-- |</span>
<span class='hs-comment'>-- Module      :  Data.List.Combinator</span>
<span class='hs-comment'>-- Copyright   :  (c) 2012 Bart Massey</span>
<span class='hs-comment'>-- License     :  BSD-style (see the file COPYING)</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Maintainer  :  bart.massey@gmail.com</span>
<span class='hs-comment'>-- Stability   :  pre-alpha</span>
<span class='hs-comment'>-- Portability :  portable</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- This re-implementation of 'Data.List' was inspired </span>
<span class='hs-comment'>-- by working with Bart Massey, Jamey Sharp and Jules</span>
<span class='hs-comment'>-- Kongslie's generalized 'fold'.  </span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- The documentation and a bit of the implementation are</span>
<span class='hs-comment'>-- either taken from or inspired by the 'base' 'Data.List'</span>
<span class='hs-comment'>-- implementation of GHC. However, this is not a</span>
<span class='hs-comment'>-- lightly-hacked 'Data.List':</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>--   * The documentation has been substantially rewritten to</span>
<span class='hs-comment'>--   provide a more accurate description</span>
<span class='hs-comment'>--   </span>
<span class='hs-comment'>--   * The primitives have been almost entirely</span>
<span class='hs-comment'>--   reimplemented, with the goal of eliminating as many</span>
<span class='hs-comment'>--   recursive constructions as possible.  Most primitives</span>
<span class='hs-comment'>--   are now implemented in terms of each other; the</span>
<span class='hs-comment'>--   remaining few are implemented in terms of a generalized</span>
<span class='hs-comment'>--   linear recursion 'lr' operation.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>--   * The handling of primitives involving numbers has</span>
<span class='hs-comment'>--   changed to use 'Integer' rather than 'Int' as the</span>
<span class='hs-comment'>--   default type. This future-proofs the library and</span>
<span class='hs-comment'>--   makes the Laws of these operations easier to use,</span>
<span class='hs-comment'>--   presumably at the expense of performance.</span>
<span class='hs-comment'>--   </span>
<span class='hs-comment'>--   * Quite a few new primitives have been added, to</span>
<span class='hs-comment'>--     fill holes in the library or just for symmetry</span>
<span class='hs-comment'>--     with existing primitives.</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- The result of this work is a library that is likely to be</span>
<span class='hs-comment'>-- less performant than the GHC 'base' library. However, it</span>
<span class='hs-comment'>-- is hopefully easier to understand, verify and maintain.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Every function described here is maximally productive,</span>
<span class='hs-comment'>-- unless otherwise specified. Informally, this means that</span>
<span class='hs-comment'>-- the result of the function will be built up in such a way</span>
<span class='hs-comment'>-- that each piece will be ready for consumption as early as</span>
<span class='hs-comment'>-- logically possible.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Each function has "laws" that are intended to specify its</span>
<span class='hs-comment'>-- behavior.  The laws are currently only intended to cover</span>
<span class='hs-comment'>-- the case of finite lists; they may or may not work in the</span>
<span class='hs-comment'>-- presence of infinite lists even if the function being</span>
<span class='hs-comment'>-- specified is maximally productive.</span>
<span class='hs-comment'>-----------------------------------------------------------------------------</span>

<span class='hs-keyword'>module</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span><span class='hs-varop'>.</span><span class='hs-conid'>Combinator</span> <span class='hs-layout'>(</span>
  <span class='hs-keyword'>module</span> <span class='hs-conid'>Prelude</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Linear Recursion</span>
  <span class='hs-varid'>lr</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Basic Functions</span>
  <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>head</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>last</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>tail</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>init</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>null</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>length</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>length'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>genericLength</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * List Transformations</span>
  <span class='hs-varid'>map</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>reverse</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>intersperse</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>separate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>separate'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>terminate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>intercalate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>transpose</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>subsequences</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>permutations</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>insertions</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Reducing Lists (Folding)</span>
  <span class='hs-varid'>fold</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldl</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldl'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldr</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldl1</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldl1'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldr1</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Special Folds</span>
  <span class='hs-varid'>concat</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>concatMap</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>and</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>or</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>any</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>all</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>sum</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>sum'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>product</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>product'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>maximum</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>minimum</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Building Lists</span>
  <span class='hs-comment'>-- ** Scans</span>
  <span class='hs-varid'>scanl</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanl1</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanr</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanr1</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- ** Accumulating Maps</span>
  <span class='hs-varid'>mapAccumL</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>mapAccumR</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- ** Infinite Lists</span>
  <span class='hs-varid'>iterate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>repeat</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>replicate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>cycle</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- ** Unfolding</span>
  <span class='hs-varid'>unfoldr</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unfoldl</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unfoldl'</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Sublists</span>
  <span class='hs-comment'>-- ** Extracting Sublists</span>
  <span class='hs-varid'>take</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>drop</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>splitAt</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>splits</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>takeWhile</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>dropWhile</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>span</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>break</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>takeWhileEnd</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>dropWhileEnd</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>spanEnd</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>breakEnd</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>stripPrefix</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>stripSuffix</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>group</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>inits</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>tails</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- ** Predicates</span>
  <span class='hs-varid'>isPrefixOf</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>isSuffixOf</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>isInfixOf</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Searching Lists</span>
  <span class='hs-comment'>-- ** Searching By Equality</span>
  <span class='hs-varid'>elem</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>notElem</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>lookup</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- ** Searching With A Predicate</span>
  <span class='hs-varid'>find</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>filter</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>partition</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Indexing Lists</span>
  <span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>elemIndex</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>elemIndices</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>findIndex</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>findIndices</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Zipping and Unzipping Lists</span>
  <span class='hs-varid'>zip</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip3</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip4</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip5</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip6</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip7</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith3</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith4</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith5</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith6</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith7</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip3</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip4</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip5</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip6</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip7</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Special Lists</span>
  <span class='hs-varid'>lines</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>words</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unlines</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unwords</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * \"Set\" Operations</span>
  <span class='hs-varid'>nub</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>delete</span><span class='hs-layout'>,</span>
  <span class='hs-layout'>(</span><span class='hs-varop'>\\</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
  <span class='hs-layout'>(</span><span class='hs-varop'>\\*</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>union</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>union'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>intersect</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>intersect'</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * Ordered Lists</span>
  <span class='hs-varid'>merge</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>sort</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>insert</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>insert'</span><span class='hs-layout'>,</span>
  <span class='hs-comment'>-- * The \"By\" Operations</span>
  <span class='hs-varid'>separateBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>separateBy'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>terminateBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>elemBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>notElemBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>nubBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>deleteBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>deleteFirstsBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>deleteFirstsBy'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unionBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unionBy'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>intersectBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>intersectBy'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>groupBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>mergeBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>sortBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>insertBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>insertBy'</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>maximumBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>minimumBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>stripPrefixBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>stripSuffixBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>isPrefixOfBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>isSuffixOfBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>isInfixOfBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>lookupBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>elemIndexBy</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>elemIndicesBy</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>

<span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span>
  <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldl</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldr</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>head</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>last</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>tail</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>init</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>null</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>length</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>map</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>reverse</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldl1</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>foldr1</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>concat</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>concatMap</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>and</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>or</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>any</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>all</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>sum</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>product</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>maximum</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>minimum</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanl</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanl1</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanr</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>scanr1</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>iterate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>repeat</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>replicate</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>cycle</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>take</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>drop</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>splitAt</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>takeWhile</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>dropWhile</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>span</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>break</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>elem</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>notElem</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>lookup</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>filter</span><span class='hs-layout'>,</span>
  <span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zip3</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>zipWith3</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unzip3</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>lines</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>words</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unlines</span><span class='hs-layout'>,</span>
  <span class='hs-varid'>unwords</span><span class='hs-layout'>)</span>
<span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Char</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSpace</span><span class='hs-layout'>)</span>


<span class='hs-comment'>-- XXX Need to write laws for this.</span>

<span class='hs-comment'>-- | Generalized linear recursion.  Given an initial left</span>
<span class='hs-comment'>-- and right accumulator and a function that steps the</span>
<span class='hs-comment'>-- accumulators forward from the left and right as with</span>
<span class='hs-comment'>-- 'fold', keep stepping until the function indicates</span>
<span class='hs-comment'>-- completion by returning 'Nothing' on the right. /O(n)/</span>
<span class='hs-comment'>-- where /n/ is the number of recursive steps, plus the cost</span>
<span class='hs-comment'>-- of evaluating the folding function.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This abstraction of 'fold' is a bidirectional</span>
<span class='hs-comment'>-- generalization of 'unfoldr': both are written as</span>
<span class='hs-comment'>-- 'lr's.</span>
<span class='hs-definition'>lr</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class='hs-definition'>lr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1</span><span class='hs-layout'>,</span> <span class='hs-varid'>mr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r2</span><span class='hs-layout'>)</span>
      <span class='hs-layout'>(</span><span class='hs-varid'>l2</span><span class='hs-layout'>,</span> <span class='hs-varid'>r2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>in</span>
  <span class='hs-keyword'>case</span> <span class='hs-varid'>mr1</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
    <span class='hs-conid'>Just</span> <span class='hs-varid'>r1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l2</span><span class='hs-layout'>,</span> <span class='hs-varid'>r1</span><span class='hs-layout'>)</span>


<span class='hs-comment'>-- XXX Need to write laws for this.</span>

<span class='hs-comment'>-- | Given a function that accepts an element and a left and</span>
<span class='hs-comment'>-- right context and produces a new left and right context,</span>
<span class='hs-comment'>-- and given an initial left and right context and a list,</span>
<span class='hs-comment'>-- run the function on each element of the list with the</span>
<span class='hs-comment'>-- appropriate context.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- The 'fold' operation generalizes a number of things from</span>
<span class='hs-comment'>-- 'Data.List', including 'foldl' and 'foldr'. It works by</span>
<span class='hs-comment'>-- allowing `f` to work with both state accumulated from the</span>
<span class='hs-comment'>-- left and state built up from the right simultaneously.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- @'fold' f (l, r)@ is fully lazy if `f` is fully lazy</span>
<span class='hs-comment'>-- on `l` and `r`, strict if at most one of `l` and `r` is</span>
<span class='hs-comment'>-- strict, and is bottom if both `l` and `r` are strict.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- One can think of 'fold' as processing each element of its</span>
<span class='hs-comment'>-- list input with a function that receives left context</span>
<span class='hs-comment'>-- calculated from its predecessors and a right context</span>
<span class='hs-comment'>-- calculated from its successors. As one traverses the list</span>
<span class='hs-comment'>-- and examines these elements, the function is run to produce</span>
<span class='hs-comment'>-- these outputs.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- There is probably a need for a version of this function</span>
<span class='hs-comment'>-- element-strict in the left context: call it 'fold'' .</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Compare this 'fold' with Noah Easterly's "bifold" discussed</span>
<span class='hs-comment'>-- a while back on Haskell-Cafe</span>
<span class='hs-comment'>-- (&lt;<a href="http://haskell.1045720.n5.nabble.com/Bifold-a-simultaneous-foldr-and-foldl-td3285581.html">http://haskell.1045720.n5.nabble.com/Bifold-a-simultaneous-foldr-and-foldl-td3285581.html</a>&gt;). That</span>
<span class='hs-comment'>-- fold is identical to this one (up to trivial signature</span>
<span class='hs-comment'>-- differences). (I do not understand whether Henning</span>
<span class='hs-comment'>-- Theielemann's "foldl'r" is the same. There is some</span>
<span class='hs-comment'>-- interesting discussion of "Q" from Backus in that thread</span>
<span class='hs-comment'>-- that I would like to absorb someday.)  In any case, I</span>
<span class='hs-comment'>-- think there is enough novelty in the use of 'fold' in</span>
<span class='hs-comment'>-- this library to be worth paying attention to. /O(n)/ plus</span>
<span class='hs-comment'>-- the cost of evaluating the folding function.</span>
<span class='hs-definition'>fold</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<span class='hs-definition'>fold</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>l0</span><span class='hs-layout'>,</span> <span class='hs-varid'>r0</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lr</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l0</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs0</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>r0</span><span class='hs-layout'>)</span> <span class='hs-keyword'>in</span>
  <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span> <span class='hs-varid'>r'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>in</span>
      <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>r'</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Append two lists, i.e.,</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- /O(m)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs . [] ++ xs == xs</span>
<span class='hs-comment'>-- &gt; forall x xs ys . x : (xs ++ ys) == (x : xs) ++ ys</span>
<span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | Return the first element of a non-empty</span>
<span class='hs-comment'>-- list. /O(1)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall l . not (null l) . (head l : tail l) == l</span>
<span class='hs-definition'>head</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>head</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class='hs-definition'>head</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"head: empty list"</span>

<span class='hs-comment'>-- | Return the last element of a non-empty</span>
<span class='hs-comment'>-- list. Strict. /O(1)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . last (xs ++ [x]) == x</span>
<span class='hs-definition'>last</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>last</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>
<span class='hs-definition'>last</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"last: empty list"</span>

<span class='hs-comment'>-- | Return the second and subsequent elements of a</span>
<span class='hs-comment'>-- non-empty list. /O(1)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . tail (x : xs) == xs</span>
<span class='hs-definition'>tail</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>tail</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
<span class='hs-definition'>tail</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"tail: empty list"</span>

<span class='hs-comment'>-- | Return all the elements of a non-empty list except the</span>
<span class='hs-comment'>-- last one. /O(1)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . init (xs ++ [x]) == xs</span>
<span class='hs-definition'>init</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>init</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xs0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Return 'True' on the empty list, and 'False'</span>
<span class='hs-comment'>-- on any other list. /O(1)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; null [] == True</span>
<span class='hs-comment'>-- &gt; forall x xs . null (x : xs) == False</span>
<span class='hs-definition'>null</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>null</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class='hs-definition'>null</span>  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>

<span class='hs-comment'>-- | Returns the length of a finite list as an 'Integer'. See also</span>
<span class='hs-comment'>-- 'genericLength'. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; length [] == 0</span>
<span class='hs-comment'>-- &gt; forall x xs . length (x : xs) == 1 + length xs</span>
<span class='hs-definition'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span>
<span class='hs-definition'>length</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>genericLength</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | Returns the length of a list with less than or</span>
<span class='hs-comment'>-- equal to 'maxBound' 'Int' elements as an 'Int'. See also</span>
<span class='hs-comment'>-- 'genericLength'. Strict. /O(n)/. Laws: </span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; length' [] == 0</span>
<span class='hs-comment'>-- &gt; forall x xs | length xs &lt; maxBound :: Int .</span>
<span class='hs-comment'>-- &gt;   length' (x : xs) == 1 + length' xs</span>
<span class='hs-definition'>length'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>length'</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>genericLength</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | Returns the length of a list with less than or equal to</span>
<span class='hs-comment'>-- @'maxBound' t@ elements as a value of type @t@, where @t@</span>
<span class='hs-comment'>-- is an 'Integral' type being used for list length. Does</span>
<span class='hs-comment'>-- something undefined on longer lists. Not the default type</span>
<span class='hs-comment'>-- for the length function, since type inference tends to</span>
<span class='hs-comment'>-- get lost and default badly if the length function does</span>
<span class='hs-comment'>-- not constrain it. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; length' [] == 0</span>
<span class='hs-comment'>-- &gt; forall x xs | length xs &lt; maxBound :: Int .</span>
<span class='hs-comment'>-- &gt;   length' (x : xs) == 1 + length' xs</span>
<span class='hs-definition'>genericLength</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>genericLength</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | @'map' f xs@ applies @f@ to each element</span>
<span class='hs-comment'>-- of @xs@ in turn and returns a list of the results, i.e.,</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ plus the cost of the function applications. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f . map f [] == []</span>
<span class='hs-comment'>-- &gt; forall f x xs . map f (x : xs) = f x : map f xs</span>
<span class='hs-definition'>map</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | 'reverse' returns the elements of its input list in</span>
<span class='hs-comment'>-- reverse order. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; reverse [] == []</span>
<span class='hs-comment'>-- &gt; forall xs | not (null xs) . </span>
<span class='hs-comment'>-- &gt;   reverse xs = last xs : reverse (init xs)</span>
<span class='hs-definition'>reverse</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>reverse</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'intersperse' function takes an element and a list and</span>
<span class='hs-comment'>-- \`intersperses\' that element between the elements of the list.</span>
<span class='hs-comment'>-- For example,</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; intersperse ',' "abcde" == "a,b,c,d,e"</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall t . intersperse t [] == []</span>
<span class='hs-comment'>-- &gt; forall t x . intersperse t [x] == [x]</span>
<span class='hs-comment'>-- &gt; forall t x xs | not (null xs) . </span>
<span class='hs-comment'>-- &gt;   intersperse t (x : xs) == x : intersperse t xs</span>
<span class='hs-definition'>intersperse</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>intersperse</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class='hs-definition'>intersperse</span> <span class='hs-varid'>s</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x'</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'separate' function takes an element and a list;</span>
<span class='hs-comment'>-- it treats the element as a \"field separator\" and</span>
<span class='hs-comment'>-- splits the list into fields (sublists) at every occurrence.</span>
<span class='hs-comment'>-- If the input list is empty, no fields are returned.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; separate ',' ",a,b,c,d," == ["","a","b","c","d",""]</span>
<span class='hs-comment'>-- &gt; separate ',' "" == []</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- 'separate' is a special case of 'separateBy' with</span>
<span class='hs-comment'>-- predicate @(== t)@. It is also a special case of</span>
<span class='hs-comment'>-- 'separate'' that handles the empty list slightly</span>
<span class='hs-comment'>-- differently. New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall t xs . separate t xs == separateBy (== t) xs</span>
<span class='hs-definition'>separate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>separate</span> <span class='hs-varid'>t</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>separateBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'separateBy' function takes a predicate @p@ and a list;</span>
<span class='hs-comment'>-- it treats any element of the list for which @p@</span>
<span class='hs-comment'>-- returns true as a \"field separator\" and splits the list</span>
<span class='hs-comment'>-- into fields (sublists) at each such occurrence.  If the</span>
<span class='hs-comment'>-- input list is empty, no fields are returned.  Some</span>
<span class='hs-comment'>-- examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; separateBy (not . isAlpha) "&amp;a+b$" == ["","a","b",""]</span>
<span class='hs-comment'>-- &gt; separateBy (not . isAlpha) "" == []</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- 'separateBy' is a special case of 'separateBy'' that</span>
<span class='hs-comment'>-- handles the empty list slightly</span>
<span class='hs-comment'>-- differently. New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . separateBy p [] = []</span>
<span class='hs-comment'>-- &gt; forall p x xs . separateBy p (x : xs) = separateBy' p (x : xs)</span>
<span class='hs-definition'>separateBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>separateBy</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class='hs-definition'>separateBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>separateBy'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'separate'' function takes an element and a list;</span>
<span class='hs-comment'>-- it treats the element as a \"field separator\" and</span>
<span class='hs-comment'>-- splits the list into fields (sublists) at every occurrence.</span>
<span class='hs-comment'>-- If the input list is empty, a single empty field is returned.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; separate' ',' ",a,b,c,d," == ["","a","b","c","d",""]</span>
<span class='hs-comment'>-- &gt; separate' ',' "" == [""]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- 'separate'' is a special case of 'separateBy'' with</span>
<span class='hs-comment'>-- predicate @(== t)@. New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall t . separate t [] == []</span>
<span class='hs-definition'>separate'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>separate'</span> <span class='hs-varid'>t</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>separateBy'</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'separateBy'' function takes a predicate @p@ and a list;</span>
<span class='hs-comment'>-- it treats any element of the list for which @p@</span>
<span class='hs-comment'>-- returns true as a \"field separator\" and splits the list</span>
<span class='hs-comment'>-- into fields (sublists) at each such occurrence.  If the</span>
<span class='hs-comment'>-- input list is empty, a single empty field is returned.  Some</span>
<span class='hs-comment'>-- examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; separateBy (not . isAlpha) "&amp;a+b$" == ["","a","b",""]</span>
<span class='hs-comment'>-- &gt; separateBy (not . isAlpha) "" == [""]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . separateBy' p [] = [[]]</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x . </span>
<span class='hs-comment'>-- &gt;   separateBy' p (x : xs) == [] : separateBy' p xs</span>
<span class='hs-comment'>-- &gt; forall p x xs ys yss | </span>
<span class='hs-comment'>-- &gt;  not (p x) &amp;&amp; (ys : yss) == separateBy' p xs .</span>
<span class='hs-comment'>-- &gt;   separateBy' p (x : xs) = (x : ys) : yss</span>
<span class='hs-definition'>separateBy'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>separateBy'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>ys</span> <span class='hs-conop'>:</span> <span class='hs-varid'>yss</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>yss</span>

<span class='hs-comment'>-- | The 'terminate' function takes an element and a list;</span>
<span class='hs-comment'>-- it treats the element as a \"field terminator\" and</span>
<span class='hs-comment'>-- splits the list into fields (sublists) before every occurrence.</span>
<span class='hs-comment'>-- If the input list is empty, no fields are returned.</span>
<span class='hs-comment'>-- If the input list is nonempty but does not end with a</span>
<span class='hs-comment'>-- terminator, an implicit final terminator is assumed.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; terminate ';' "a;b;c;d;" == ["a","b","c","d"]</span>
<span class='hs-comment'>-- &gt; terminate ';' "a;b" == ["a","b"]</span>
<span class='hs-comment'>-- &gt; terminate ';' ";" == [""]</span>
<span class='hs-comment'>-- &gt; terminate ';' [] == []</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- 'terminate' is a special case of 'terminateBy' with</span>
<span class='hs-comment'>-- predicate @(== t)@. New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall t xs . terminate t xs == terminateBy (== t) xs</span>
<span class='hs-definition'>terminate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>terminate</span> <span class='hs-varid'>t</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>terminateBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'terminateBy' function takes a predicate @p@ and a list;</span>
<span class='hs-comment'>-- it treats any  element for which @p@ holds as a \"field terminator\" and</span>
<span class='hs-comment'>-- splits the list into fields (sublists) before each such occurrence.</span>
<span class='hs-comment'>-- If the input list is empty, no fields are returned.</span>
<span class='hs-comment'>-- If the input list is nonempty but does not end with a</span>
<span class='hs-comment'>-- terminator, an implicit final terminator is assumed.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; terminateBy (`elem` ";.") "a;b." == ["a","b"]</span>
<span class='hs-comment'>-- &gt; terminateBy (`elem` ";.") "a;b" == ["a","b"]</span>
<span class='hs-comment'>-- &gt; terminateBy (`elem` ";.") "" == []</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . terminateBy p [] = []</span>
<span class='hs-comment'>-- &gt; forall p x | p x . terminateBy p [x] == [[]]</span>
<span class='hs-comment'>-- &gt; forall p x | not (p x) . terminateBy p [x] == [[x]]</span>
<span class='hs-comment'>-- &gt; forall p x1 x2 xs yss | </span>
<span class='hs-comment'>-- &gt;  p x1 &amp;&amp; yss == terminateBy p (x2 : xs) .</span>
<span class='hs-comment'>-- &gt;   terminateBy p (x1 : x2 : xs) == [] : yss</span>
<span class='hs-comment'>-- &gt; forall p x1 x2 xs ys yss | </span>
<span class='hs-comment'>-- &gt;  not (p x1) &amp;&amp; (ys : yss) == terminateBy p (x2 : xs) .</span>
<span class='hs-comment'>-- &gt;   terminateBy p (x1 : x2 : xs) == (x1 : ys) : yss</span>
<span class='hs-definition'>terminateBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>terminateBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>case</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
    <span class='hs-conid'>Just</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>ys</span> <span class='hs-conop'>:</span> <span class='hs-varid'>yss</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>yss</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- This intercalate is taken directly from Data.List.</span>

<span class='hs-comment'>-- | @'intercalate' xs xss@ inserts the list @xs@ in between</span>
<span class='hs-comment'>-- the lists in @xss@ and returns the concatenation of</span>
<span class='hs-comment'>-- resulting lists. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs xss .</span>
<span class='hs-comment'>-- &gt;   intercalate xs xss == concat (intersperse xs xss)</span>
<span class='hs-definition'>intercalate</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>intercalate</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-layout'>(</span><span class='hs-varid'>intersperse</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>xss</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'transpose' function transposes the rows and columns of its argument.</span>
<span class='hs-comment'>-- For example,</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt;&gt;&gt; transpose [["a1","b1"],["a2","b2","c2"],["a3","b3"]]</span>
<span class='hs-comment'>-- [["a1","a2","a3"],["b1","b2","b3"],["c2"]]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ where /n/ is the number of elements to be</span>
<span class='hs-comment'>-- transposed. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xss yss | yss == filter (not . null) xss &amp;&amp; null yss . </span>
<span class='hs-comment'>-- &gt;   transpose xss == []</span>
<span class='hs-comment'>-- &gt; forall xss yss | yss == filter (not . null) xss &amp;&amp; not (null yss) . </span>
<span class='hs-comment'>-- &gt;   transpose xss == map head yss : transpose (map tail yss)</span>
<span class='hs-definition'>transpose</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>transpose</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xss</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> 
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span>
          <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span>
        <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>null</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>
        <span class='hs-varid'>g</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>h</span><span class='hs-layout'>,</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:</span> <span class='hs-varid'>h</span><span class='hs-layout'>,</span> <span class='hs-varid'>ys</span> <span class='hs-conop'>:</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'subsequences' function returns the list of all</span>
<span class='hs-comment'>-- subsequences (ordered sublists) of its argument, in no</span>
<span class='hs-comment'>-- specified order. /O(2^n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; subsequences [] == [[]]</span>
<span class='hs-comment'>-- &gt; forall x xs . subsequences (x : xs) `elem` </span>
<span class='hs-comment'>-- &gt;   permutations (subsequences xs ++ map (x :) (subsequences xs))</span>
<span class='hs-definition'>subsequences</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>subsequences</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'permutations' function returns the list of lists</span>
<span class='hs-comment'>-- of all permutations of its list argument, in no specified</span>
<span class='hs-comment'>-- order. /O(n!)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; permutations [] == [[]]</span>
<span class='hs-comment'>-- &gt; forall x xs . permutations (x : xs) `elem`</span>
<span class='hs-comment'>-- &gt;   permutations (concatMap (insertions x) (permutations xs))</span>
<span class='hs-definition'>permutations</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>permutations</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>insertions</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>

<span class='hs-comment'>-- | @'insertions' t xs@ returns a list of the lists</span>
<span class='hs-comment'>-- obtained by inserting @t@ at every position in @xs@ in</span>
<span class='hs-comment'>-- sequence, in order from left to</span>
<span class='hs-comment'>-- right. New. /O(n^2)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall t . insertions t [] == [[t]]</span>
<span class='hs-comment'>-- &gt; forall t x xs . </span>
<span class='hs-comment'>-- &gt;   insertions t (x : xs) == [t : x : xs] : map (x :) (insertions t xs)</span>
<span class='hs-definition'>insertions</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>insertions</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>y</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'foldl', applied to a binary operator @f@, a starting value (typically</span>
<span class='hs-comment'>-- the left-identity of the operator) @a@, and a list, reduces the list</span>
<span class='hs-comment'>-- using @f@, from left to right:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; foldl f a [x1, x2, ..., xn] == (...((a `f` x1) `f` x2) `f`...) `f` xn</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- The starting value @a@ is best thought of as an \"accumulator\" that</span>
<span class='hs-comment'>-- is passed from the beginning to the end of the list and then returned.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Strict. /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a . foldl f a [] == a</span>
<span class='hs-comment'>-- &gt; forall a x xs . foldl f a (x : xs) == foldl f (f a x) xs</span>
<span class='hs-definition'>foldl</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>fst</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>f'</span> <span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- XXX The strictness isn't right here currently, maybe?</span>

<span class='hs-comment'>-- | The semantics of 'foldl'' those of 'foldl', except that</span>
<span class='hs-comment'>-- 'foldl'' eagerly applies @f@ at each step. This gains</span>
<span class='hs-comment'>-- some operational efficiency, but makes 'foldl'' only</span>
<span class='hs-comment'>-- partially correct: there are cases where 'foldl' would</span>
<span class='hs-comment'>-- return a value, but 'foldl'' on the same arguments will</span>
<span class='hs-comment'>-- nonterminate or fail. The Laws for 'foldl'' are thus</span>
<span class='hs-comment'>-- the same as those for 'foldl' up to a condition on @f@,</span>
<span class='hs-comment'>-- which is not given here.</span>
<span class='hs-definition'>foldl'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>foldl'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>fst</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>f'</span> <span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'foldl1' is a variant of 'foldl' that </span>
<span class='hs-comment'>-- starts the fold with the accumulator set</span>
<span class='hs-comment'>-- to the first element of the list; this</span>
<span class='hs-comment'>-- requires that its list argument be nonempty.</span>
<span class='hs-comment'>-- Spine-strict. /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f x xs . foldl1 f (x : xs) == foldl f x xs</span>
<span class='hs-definition'>foldl1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>foldl1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> 
<span class='hs-definition'>foldl1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"foldl1: empty list"</span>

<span class='hs-comment'>-- | 'foldl1'' bears the same relation to 'foldl1' that</span>
<span class='hs-comment'>-- 'foldl'' bears to 'foldl'.</span>
<span class='hs-definition'>foldl1'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>foldl1'</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> 
<span class='hs-definition'>foldl1'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"foldl1': empty list"</span>

<span class='hs-comment'>-- | 'foldr', applied to a binary operator @f@, a starting value (typically</span>
<span class='hs-comment'>-- the right-identity of the operator) @a@, and a list, reduces the list</span>
<span class='hs-comment'>-- using @f@, from right to left:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; foldr f a [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` a)...)</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- The starting value @a@ is best thought of as an</span>
<span class='hs-comment'>-- \"accumulator\" that is returned from processing the last</span>
<span class='hs-comment'>-- element of the list and processed by subsequent returns,</span>
<span class='hs-comment'>-- finally being returned as the result. Because 'foldr' is</span>
<span class='hs-comment'>-- lazy, and proceeds (of necessity) by calls from left to</span>
<span class='hs-comment'>-- right on the list, it is possible for 'foldr' to \"stop</span>
<span class='hs-comment'>-- processing early\" if @f@ simply returns its accumulator</span>
<span class='hs-comment'>-- @a@. /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a . foldr f a [] == a</span>
<span class='hs-comment'>-- &gt; forall f a x xs . foldr f a (x : xs) == f x (foldr f a xs)</span>
<span class='hs-definition'>foldr</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<span class='hs-definition'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>f'</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span><span class='hs-layout'>,</span> <span class='hs-varid'>b0</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'foldr1' is a variant of 'foldr' that </span>
<span class='hs-comment'>-- folds with the accumulator set</span>
<span class='hs-comment'>-- to the last element of the list; this</span>
<span class='hs-comment'>-- requires that its list argument be nonempty.</span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f xs x . foldr1 f (xs ++ [x]) == foldr f x xs</span>
<span class='hs-definition'>foldr1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>foldr1</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>f'</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>a0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Given a list of lists, \"concatenate\" the lists, that</span>
<span class='hs-comment'>-- is, append them all together to make a list of the</span>
<span class='hs-comment'>-- elements. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; concat [] == []</span>
<span class='hs-comment'>-- &gt; forall xs xss . concat (xs : xss) == xs ++ concat xss</span>
<span class='hs-definition'>concat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>concat</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xss</span>

<span class='hs-comment'>-- | Apply 'concat' to the result of 'map'-ing a function</span>
<span class='hs-comment'>-- @f@ onto a list; the result of @f@ must of necessity be a</span>
<span class='hs-comment'>-- list.  A convenience function, and may be more efficient</span>
<span class='hs-comment'>-- by a constant factor than the obvious</span>
<span class='hs-comment'>-- implementation. /O(n)/ plus the cost of evaluating</span>
<span class='hs-comment'>-- @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f xs . concatMap f xs == concat (map f xs)</span>
<span class='hs-definition'>concatMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>concatMap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'and' function returns the conjunction of the</span>
<span class='hs-comment'>-- elements of its 'Boolean' list argument. This is</span>
<span class='hs-comment'>-- \"short-circuiting\" 'and': it scans the list from left</span>
<span class='hs-comment'>-- to right, returning 'False' the first time a 'False'</span>
<span class='hs-comment'>-- element is encountered. Thus, it is strict in the case</span>
<span class='hs-comment'>-- the list is entirely 'True', and spine-lazy</span>
<span class='hs-comment'>-- otherwise. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- and [] == True</span>
<span class='hs-comment'>-- forall x xs . and (x : xs) == x &amp;&amp; and xs</span>
<span class='hs-definition'>and</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bool</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>and</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varop'>&amp;&amp;</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span>

<span class='hs-comment'>-- | The 'or' function returns the disjunction of the</span>
<span class='hs-comment'>-- elements of its 'Boolean' list argument. This is</span>
<span class='hs-comment'>-- \"short-circuiting\" 'or': it scans the list from left</span>
<span class='hs-comment'>-- to right, returning 'True' the first time a 'True'</span>
<span class='hs-comment'>-- element is encountered. Thus, it is strict in the case</span>
<span class='hs-comment'>-- the list is entirely 'False', and spine-lazy</span>
<span class='hs-comment'>-- otherwise. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- or [] == False</span>
<span class='hs-comment'>-- forall x xs . or (x : xs) == x || or xs</span>
<span class='hs-definition'>or</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bool</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>or</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varop'>||</span><span class='hs-layout'>)</span> <span class='hs-conid'>False</span>

<span class='hs-comment'>-- | The 'any' function returns 'True' if its predicate</span>
<span class='hs-comment'>-- argument @p@ applied to any element of its list argument</span>
<span class='hs-comment'>-- returns 'True', and returns 'False' otherwise. This is</span>
<span class='hs-comment'>-- \"short-circuiting\" any, as with 'or'. /O(n)/ plus the</span>
<span class='hs-comment'>-- cost of evaluating @p@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . any p xs == or (map p xs)</span>
<span class='hs-definition'>any</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>any</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>or</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>p</span>

<span class='hs-comment'>-- | The 'all' function returns 'False' if its predicate</span>
<span class='hs-comment'>-- argument @p@ applied to any element of its list argument</span>
<span class='hs-comment'>-- returns 'False', and returns 'True' otherwise. This is</span>
<span class='hs-comment'>-- \"short-circuiting\" any, as with 'and'. /O(n)/ plus the</span>
<span class='hs-comment'>-- cost of evaluating @p@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . all p xs == and (map p xs)</span>
<span class='hs-definition'>all</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>all</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>and</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>p</span>

<span class='hs-comment'>-- | Returns the sum of a list of numeric arguments. The</span>
<span class='hs-comment'>-- sum of the empty list is defined to be @0@.</span>
<span class='hs-comment'>-- [New. See 'sum'' below.] Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- sum [] == 0</span>
<span class='hs-comment'>-- forall x xs . sum (x : xs) == x + sum xs</span>
<span class='hs-definition'>sum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>sum</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-varid'>foldl'</span> <span class='hs-varid'>plus</span> <span class='hs-num'>0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>a</span> <span class='hs-varop'>`plus`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>b</span>


<span class='hs-comment'>-- | Returns the sum of a list of numeric arguments. The</span>
<span class='hs-comment'>-- sum of the empty list is defined to be @0@.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This should be element-strict (like foldl'), but this is</span>
<span class='hs-comment'>-- not allowed by the Standard (according to the GHC folks),</span>
<span class='hs-comment'>-- because it is possible that some kind of non-standard</span>
<span class='hs-comment'>-- non-strict \"numbers\" could be implemented as a 'Num'</span>
<span class='hs-comment'>-- instance. Thus, with standard numbers, this sum will</span>
<span class='hs-comment'>-- not be executed at all efficiently: the result will</span>
<span class='hs-comment'>-- be a function that, when evaluated, will produce a sum.</span>
<span class='hs-comment'>-- To be fair, compiler strictness analysis will usually</span>
<span class='hs-comment'>-- fix this problem: you will normally only see it when</span>
<span class='hs-comment'>-- the compiler fails to optimize.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- sum' [] == 0</span>
<span class='hs-comment'>-- forall x xs . sum' (x : xs) == x + sum' xs</span>
<span class='hs-definition'>sum'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>sum'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span>

<span class='hs-comment'>-- | Returns the product of a list of numeric arguments. The</span>
<span class='hs-comment'>-- product of the empty list is defined to be @1@. This</span>
<span class='hs-comment'>-- version will terminate early if a numeric @0@ is</span>
<span class='hs-comment'>-- encountered in the list, and thus will work on infinite</span>
<span class='hs-comment'>-- lists containing @0@ and will be more efficient on lists</span>
<span class='hs-comment'>-- containing @0@. [New. See 'product'' below.]</span>
<span class='hs-comment'>-- Strict, up to handling @0@. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; product [] == 1</span>
<span class='hs-comment'>-- &gt; forall x xs . product (x : xs) == x * product xs</span>
<span class='hs-definition'>product</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>product</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>times</span> <span class='hs-num'>1</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-num'>0</span> <span class='hs-varop'>`times`</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
    <span class='hs-keyword'>_</span> <span class='hs-varop'>`times`</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
    <span class='hs-varid'>x</span> <span class='hs-varop'>`times`</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>y</span>

<span class='hs-comment'>-- | Returns the product of a list of numeric arguments. The</span>
<span class='hs-comment'>-- product of the empty list is defined to be @1@.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Because standard numeric (*) is</span>
<span class='hs-comment'>-- strict, this will not terminate early as expected when taking</span>
<span class='hs-comment'>-- products with standard numeric @0@. Nonetheless, as with 'sum'',</span>
<span class='hs-comment'>-- this product is apparently required to be element-lazy.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; product' [] == 1</span>
<span class='hs-comment'>-- &gt; forall x xs . product' (x : xs) == x * product' xs</span>
<span class='hs-definition'>product'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>product'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-num'>1</span>

<span class='hs-comment'>-- | The 'maximum' function returns a maximum value from a</span>
<span class='hs-comment'>-- non-empty list of 'Ord' elements. If there are multiple</span>
<span class='hs-comment'>-- maxima, the choice of which to return is</span>
<span class='hs-comment'>-- unspecified. This is a special case of 'maximumBy' with</span>
<span class='hs-comment'>-- comparison function 'compare'. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs | not (null xs) . maximum xs == maximumBy compare xs</span>
<span class='hs-definition'>maximum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>maximum</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximumBy</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'maximum' function returns a maximum value from a</span>
<span class='hs-comment'>-- non-empty list of elements using a provided comparison</span>
<span class='hs-comment'>-- function. If there are multiple maxima, the choice of</span>
<span class='hs-comment'>-- which to return is unspecified. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall c x . maximumBy c [x] == x</span>
<span class='hs-comment'>-- &gt; forall c x xs | </span>
<span class='hs-comment'>-- &gt;  not (null xs) &amp;&amp; c x (maximumBy c xs) /= LT .</span>
<span class='hs-comment'>-- &gt;   maximumBy c (x : xs) == x</span>
<span class='hs-comment'>-- &gt; forall c x xs | </span>
<span class='hs-comment'>-- &gt;  not (null xs) &amp;&amp; c x (maximumBy c xs) == LT .</span>
<span class='hs-comment'>-- &gt;   maximumBy c (x : xs) == maximumBy c xs</span>
<span class='hs-definition'>maximumBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>maximumBy</span> <span class='hs-varid'>c</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldl1'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>x1</span> <span class='hs-varop'>`f`</span> <span class='hs-varid'>x2</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x1</span> <span class='hs-varop'>`c`</span> <span class='hs-varid'>x2</span> <span class='hs-varop'>==</span> <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x2</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x1</span>

<span class='hs-comment'>-- | The 'minimum' function returns a minimum value from a</span>
<span class='hs-comment'>-- non-empty list of 'Ord' elements.  If there are multiple</span>
<span class='hs-comment'>-- minima, the choice of which to return is</span>
<span class='hs-comment'>-- unspecified. This is a special case of 'minimumBy' with</span>
<span class='hs-comment'>-- comparison function 'compare'. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs | not (null xs). minimum xs == minimumBy compare xs</span>
<span class='hs-definition'>minimum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>minimum</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minimumBy</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'minimum' function returns a minimum value from a</span>
<span class='hs-comment'>-- non-empty list of 'Ord' elements</span>
<span class='hs-comment'>-- function. If there are multiple minima, the choice of</span>
<span class='hs-comment'>-- which to return is unspecified. Strict. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall c x . minimumBy c [x] == x</span>
<span class='hs-comment'>-- &gt; forall c x xs | </span>
<span class='hs-comment'>-- &gt;  not (null xs) &amp;&amp; c x (minimumBy c xs) /= GT .</span>
<span class='hs-comment'>-- &gt;   minimumBy c (x : xs) == x</span>
<span class='hs-comment'>-- &gt; forall c x xs | </span>
<span class='hs-comment'>-- &gt;  not (null xs) &amp;&amp; c x (minimumBy c xs) == GT .</span>
<span class='hs-comment'>-- &gt;   minimumBy c (x : xs) == minimumBy c xs</span>
<span class='hs-definition'>minimumBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>minimumBy</span> <span class='hs-varid'>c</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldl1'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>x1</span> <span class='hs-varop'>`f`</span> <span class='hs-varid'>x2</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x1</span> <span class='hs-varop'>`c`</span> <span class='hs-varid'>x2</span> <span class='hs-varop'>==</span> <span class='hs-conid'>GT</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x2</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x1</span>

<span class='hs-comment'>-- | The 'scanl' function is similar to 'foldl', </span>
<span class='hs-comment'>-- in that 'scanl' passes an accumulator from left to right.</span>
<span class='hs-comment'>-- However, 'scanl' returns a list of successive accumulator values:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; scanl f a [x1, x2, ...] == [a, a `f` x1, (a `f` x1) `f` x2, ...]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Spine-strict. /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a . scanl f a [] == [a]</span>
<span class='hs-comment'>-- &gt; forall f a x xs . scanl f a (x : xs) == a : scanl f (f a x) xs</span>
<span class='hs-definition'>scanl</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>scanl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-layout'>(</span><span class='hs-varid'>a0</span> <span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>g</span> <span class='hs-varid'>a0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>a'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>a'</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'scanl1' function is to 'scanl' as 'foldl1' is to 'foldl'.</span>
<span class='hs-comment'>-- Spine-strict. /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f x xs . scanl1 f (x : xs) == scanl f x xs</span>
<span class='hs-definition'>scanl1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>scanl1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scanl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>
<span class='hs-definition'>scanl1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"scanl1: empty list"</span>

<span class='hs-comment'>-- | The 'scanr' function is similar to 'foldr', in that</span>
<span class='hs-comment'>-- 'scanr' passes an accumulator from right to left.</span>
<span class='hs-comment'>-- However, 'scanr' returns a list of accumulator values (in</span>
<span class='hs-comment'>-- the order consistent with the</span>
<span class='hs-comment'>-- definition). Spine-strict. /O(n)/ plus the cost of</span>
<span class='hs-comment'>-- evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a . scanr f a [] == [a]</span>
<span class='hs-comment'>-- &gt; forall f a b x xs | bs == scanr f a xs . </span>
<span class='hs-comment'>-- &gt;   scanr f a (x : xs) == f x (head bs) : bs</span>
<span class='hs-definition'>scanr</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>scanr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f'</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a0</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>as</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span>
    <span class='hs-varid'>f'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"scanr: internal error: fell off end"</span>

<span class='hs-comment'>-- | The 'scanr1' function is to 'scanr' as 'foldr1' is to 'foldr'.</span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f x xs . scanr1 f (xs ++ [x]) == scanr f x xs</span>
<span class='hs-definition'>scanr1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>scanr1</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f'</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>as</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span>

<span class='hs-comment'>-- | The 'mapAccumL' function behaves like a combination of</span>
<span class='hs-comment'>-- 'map' and 'foldl'; it applies a function to each element</span>
<span class='hs-comment'>-- of a list, passing an accumulating parameter from left to</span>
<span class='hs-comment'>-- right, and returns a final value of this accumulator</span>
<span class='hs-comment'>-- together with the new list. /O(n)/ plus the cost</span>
<span class='hs-comment'>-- of evaluating the folding function. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a . mapAccumL f a [] == (a, [])</span>
<span class='hs-comment'>-- &gt; forall f a a' a'' x x' xs xs''</span>
<span class='hs-comment'>-- &gt;   | (a', x') == f a x &amp;&amp; (a'', xs'') == mapAccumL f a' xs .</span>
<span class='hs-comment'>-- &gt;     mapAccumL f a (x : xs) == (a'', x' : xs'')</span>
<span class='hs-definition'>mapAccumL</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>mapAccumL</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>fold</span> <span class='hs-varid'>f'</span> <span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span> <span class='hs-varid'>r'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>l</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span>
      <span class='hs-layout'>(</span><span class='hs-varid'>l'</span><span class='hs-layout'>,</span> <span class='hs-varid'>r'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'mapAccumR' function behaves like a combination of</span>
<span class='hs-comment'>-- 'map' (which is essentially a 'foldr') and (another)</span>
<span class='hs-comment'>-- 'foldr'; it applies a function to each element of a list,</span>
<span class='hs-comment'>-- passing an accumulating parameter from right to left, and</span>
<span class='hs-comment'>-- returns a final value of this accumulator together with</span>
<span class='hs-comment'>-- the new list. </span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Watch out: the folding function takes its</span>
<span class='hs-comment'>-- arguments in the opposite order of 'foldr'. Given that</span>
<span class='hs-comment'>-- 'mapAccumR' is essentially a 'foldr' on a pair, it</span>
<span class='hs-comment'>-- probably should not exist. </span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating the folding</span>
<span class='hs-comment'>-- function. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a xs . mapAccumR f a [] == (a, [])</span>
<span class='hs-comment'>-- &gt; forall f a a' a'' x x'' xs xs''</span>
<span class='hs-comment'>-- &gt;   | (a'', x'') == f a' x &amp;&amp; (a', xs') == mapAccumR f a xs .</span>
<span class='hs-comment'>-- &gt;     mapAccumR f a (x : xs) == (a'', x'' : xs')</span>
<span class='hs-definition'>mapAccumR</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>mapAccumR</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f'</span> <span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>r'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span>
      <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>r'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | @'iterate' f x@ returns an infinite list of repeated</span>
<span class='hs-comment'>-- applications of @f@ to @x@:</span>
<span class='hs-comment'>--     </span>
<span class='hs-comment'>-- &gt; iterate f x == [x, f x, f (f x), ...]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- Time complexity of this is almost entirely dependent on the</span>
<span class='hs-comment'>-- cost of evaluating @f@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f x . iterate f x == x : iterate f (f x)</span>
<span class='hs-definition'>iterate</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>iterate</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | @'repeat' x@ is an infinite list, with @x@ the value of</span>
<span class='hs-comment'>-- every element. /O(1)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x . repeat x == x : repeat x</span>
<span class='hs-definition'>repeat</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>repeat</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cycle</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>

<span class='hs-comment'>-- | Given a count @n@ and an element @e@, produce a list of</span>
<span class='hs-comment'>-- @e@s of length @n@.  This function is equivalent to</span>
<span class='hs-comment'>-- 'Data.List.genericReplicate'. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall n e . replicate n e == take n (repeat e)</span>
<span class='hs-definition'>replicate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>replicate</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varop'>.</span> <span class='hs-varid'>repeat</span>

<span class='hs-comment'>-- | Given an input list @xs@, return a</span>
<span class='hs-comment'>-- list consisting of an infinite repetition of</span>
<span class='hs-comment'>-- the elements of @xs@. /O(1)/ due to data recursion. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs . cycle xs == concat (repeat xs)</span>
<span class='hs-definition'>cycle</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>cycle</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- XXX Need to write laws for this.</span>

<span class='hs-comment'>-- | The 'unfoldr' function is a \"dual\" to 'foldr': while</span>
<span class='hs-comment'>-- 'foldr' reduces a list to a summary value, 'unfoldr'</span>
<span class='hs-comment'>-- builds a list from a seed value.  The function takes the</span>
<span class='hs-comment'>-- current accumulator and returns 'Nothing' if it is done</span>
<span class='hs-comment'>-- producing the list. Otherwise, it returns @'Just' (x, a)@,</span>
<span class='hs-comment'>-- in which case @x@ is a prepended to the list and @a@ is</span>
<span class='hs-comment'>-- used as the next accumulator in a recursive call.  For</span>
<span class='hs-comment'>-- example,</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; iterate f == unfoldr (\x -&gt; Just (x, f x))</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- In some cases 'unfoldr' can undo a 'foldr' operation:</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; unfoldr f' (foldr f a0 xs) == xs</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- This works if the following hold:</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; f' (f x a) = Just (x, a)</span>
<span class='hs-comment'>-- &gt; f' a0      = Nothing</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- A simple use of unfoldr:</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10</span>
<span class='hs-comment'>-- &gt;  [10,9,8,7,6,5,4,3,2,1]</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating @f@, where /n/ is the</span>
<span class='hs-comment'>-- length of the produced list.</span>
<span class='hs-definition'>unfoldr</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>unfoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lr</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>case</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span>
        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> 
          <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>a'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
          <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | An 'unfoldl' is provided for completeness. New.</span>
<span class='hs-comment'>-- Spine-strict. /O(n)/ plus the cost of evaluating the</span>
<span class='hs-comment'>-- unfolding function. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall f a . unfoldl f a == reverse (unfoldr (fmap flip f) a)</span>
<span class='hs-definition'>unfoldl</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>unfoldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lr</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>case</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span>
        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> 
          <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
          <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | An 'unfoldl'' is provided for the same reasons as</span>
<span class='hs-comment'>-- 'foldl''.  Element-strict and spine-strict. /O(n)/</span>
<span class='hs-comment'>-- plus the cost of evaluating the unfolding function.</span>
<span class='hs-definition'>unfoldl'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>unfoldl'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lr</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>case</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span>
        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> 
          <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
          <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>a'</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>


<span class='hs-comment'>-- XXX Strictness bug:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt;&gt;&gt; take 1 $ insertBy' compare 2 [1, undefined]</span>
<span class='hs-comment'>-- [1*** Exception: Prelude.undefined</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- After messing with it for an hour, I have no clue why.</span>

<span class='hs-comment'>-- | @'take' n@, applied to a list @xs@, returns the prefix of @xs@</span>
<span class='hs-comment'>-- of length @n@, or @xs@ itself if @n &gt; 'length' xs@.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; take 5 "Hello World!" == "Hello"</span>
<span class='hs-comment'>-- &gt; take 3 [1,2,3,4,5] == [1,2,3]</span>
<span class='hs-comment'>-- &gt; take 3 [1,2] == [1,2]</span>
<span class='hs-comment'>-- &gt; take 3 [] == []</span>
<span class='hs-comment'>-- &gt; take (-1) [1,2] == []</span>
<span class='hs-comment'>-- &gt; take 0 [1,2] == []</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This function is equivalent to</span>
<span class='hs-comment'>-- 'Data.List.genericTake'. /O(n)/ where /n/ is</span>
<span class='hs-comment'>-- the number of elements taken. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall n xs | n &lt;= 0 . take n xs == []</span>
<span class='hs-comment'>-- &gt; forall n | n &gt;= 0 . take n [] == []</span>
<span class='hs-comment'>-- &gt; forall n (x : xs) | n &gt; 0 . </span>
<span class='hs-comment'>-- &gt;   take n (x : xs) == x : take (n - 1) xs</span>
<span class='hs-definition'>take</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>take</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>splitAt</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | 'drop' @n xs@ returns the suffix of @xs@</span>
<span class='hs-comment'>-- after the first @n@ elements, or @[]@ if @n &gt; 'length' xs@.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; drop 6 "Hello World!" == "World!"</span>
<span class='hs-comment'>-- &gt; drop 3 [1,2,3,4,5] == [4,5]</span>
<span class='hs-comment'>-- &gt; drop 3 [1,2] == []</span>
<span class='hs-comment'>-- &gt; drop 3 [] == []</span>
<span class='hs-comment'>-- &gt; drop (-1) [1,2] == [1,2]</span>
<span class='hs-comment'>-- &gt; drop 0 [1,2] == [1,2]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This function is equivalent to</span>
<span class='hs-comment'>-- 'Data.List.genericDrop'. /O(n)/.</span>
<span class='hs-comment'>-- Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall n xs | n &lt;= 0 . drop n xs == xs</span>
<span class='hs-comment'>-- &gt; forall n | n &gt;= 0 . drop n [] == []</span>
<span class='hs-comment'>-- &gt; forall n (x : xs) | n &gt; 0 . </span>
<span class='hs-comment'>-- &gt;   drop n (x : xs) == drop (n - 1) xs</span>
<span class='hs-definition'>drop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>drop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>splitAt</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | 'splitAt' @n xs@ returns a tuple where first element is @xs@ prefix of</span>
<span class='hs-comment'>-- length @n@ and second element is the remainder of the list:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; splitAt 6 "Hello World!" == ("Hello ","World!")</span>
<span class='hs-comment'>-- &gt; splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])</span>
<span class='hs-comment'>-- &gt; splitAt 1 [1,2,3] == ([1],[2,3])</span>
<span class='hs-comment'>-- &gt; splitAt 3 [1,2,3] == ([1,2,3],[])</span>
<span class='hs-comment'>-- &gt; splitAt 4 [1,2,3] == ([1,2,3],[])</span>
<span class='hs-comment'>-- &gt; splitAt 0 [1,2,3] == ([],[1,2,3])</span>
<span class='hs-comment'>-- &gt; splitAt (-1) [1,2,3] == ([],[1,2,3])</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- @splitAt n xs@ is equivalent to @('take' n xs, 'drop' n xs)@. [This</span>
<span class='hs-comment'>-- is a generalization of 'Data.List.genericSplitAt' in that</span>
<span class='hs-comment'>-- the top-level tuple is always returned even if /n/ is bottom.]</span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall n xs . splitAt n xs = (take n xs, drop n xs)</span>
<span class='hs-definition'>splitAt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>splitAt</span> <span class='hs-varid'>n0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n0</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class='hs-definition'>splitAt</span> <span class='hs-varid'>n0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>n0</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>ls</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ls</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Returns a list of all possible splits of its list</span>
<span class='hs-comment'>-- argument as produced by 'splitAt' in order of</span>
<span class='hs-comment'>-- increasing @n@. New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall n xs | length xs == n .</span>
<span class='hs-comment'>-- &gt;   splits xs == zipWith splitAt [0..n] (repeat xs)</span>
<span class='hs-definition'>splits</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>splits</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>xs0</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>splitAt</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs0</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'takeWhile' function applied to a predicate @p@ and</span>
<span class='hs-comment'>-- a list @xs@ returns the longest prefix (possibly empty)</span>
<span class='hs-comment'>-- of @xs@ of elements that satisfy @p@. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]</span>
<span class='hs-comment'>-- &gt; takeWhile (&lt; 9) [1,2,3] == [1,2,3]</span>
<span class='hs-comment'>-- &gt; takeWhile (&lt; 0) [1,2,3] == []</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating @p@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs | not (p x) . </span>
<span class='hs-comment'>-- &gt;   takeWhile p (x : xs) == []</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x . </span>
<span class='hs-comment'>-- &gt;   takeWhile p (x : xs) == x : takeWhile p xs</span>
<span class='hs-definition'>takeWhile</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>takeWhile</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>span</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | @'dropWhile' p xs@ returns the suffix remaining after</span>
<span class='hs-comment'>-- @'takeWhile' p xs@. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]</span>
<span class='hs-comment'>-- &gt; dropWhile (&lt; 9) [1,2,3] == []</span>
<span class='hs-comment'>-- &gt; dropWhile (&lt; 0) [1,2,3] == [1,2,3]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating @p@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs | not (p x) . </span>
<span class='hs-comment'>-- &gt;   dropWhile p (x : xs) == x : xs</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x . </span>
<span class='hs-comment'>-- &gt;   dropWhile p (x : xs) == dropWhile p xs</span>
<span class='hs-definition'>dropWhile</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>dropWhile</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>span</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- Weird new list functions, but OK.</span>

<span class='hs-comment'>-- | The 'spanEnd' function returns a tuple whose second element</span>
<span class='hs-comment'>-- is the largest suffix of its list argument @xs@ such that</span>
<span class='hs-comment'>-- its predicate @p@ holds for every element; the first element</span>
<span class='hs-comment'>-- of the returned tuple is the remaining prefix of the list.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; spanEnd isSpace "foo bar \n" == ("foo bar", " \n")</span>
<span class='hs-comment'>-- &gt; spanEnd isSpace "foo bar" == ("foo bar", "")</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- @'spanEnd' p xs@ is equivalent to </span>
<span class='hs-comment'>-- @('takeWhileEnd' p xs, 'dropWhileEnd' p xs)@.</span>
<span class='hs-comment'>-- New. /O(n)/ plus the cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall p xs . spanEnd p xs == (takeWhileEnd p xs, dropWhileEnd p xs)</span>
<span class='hs-definition'>spanEnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>spanEnd</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>ok</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ts</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ts</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ts</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'breakEnd' function returns a tuple whose second element</span>
<span class='hs-comment'>-- is the largest suffix of its list argument @xs@ such that</span>
<span class='hs-comment'>-- its predicate @p@ does not hold for any element; the first element</span>
<span class='hs-comment'>-- of the returned tuple is the remaining prefix of the list.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; breakEnd isSpace "foo bar" == ("foo ", "bar")</span>
<span class='hs-comment'>-- &gt; breakEnd isSpace "foobar" == ("", "foobar")</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- @'breakEnd' p xs@ is equivalent to </span>
<span class='hs-comment'>-- @'spanEnd' (not p) xs@.</span>
<span class='hs-comment'>-- New. /O(n)/ plus the cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall p xs . breakEnd p xs == spanEnd (not p) xs</span>
<span class='hs-definition'>breakEnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>breakEnd</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spanEnd</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'takeWhileEnd' function returns the largest suffix of a list</span>
<span class='hs-comment'>-- in which the given predicate holds for all elements.  Some examples:</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; takeWhileEnd isSpace "foo\n" == "\n"</span>
<span class='hs-comment'>-- &gt; takeWhileEnd isSpace "foo bar" == ""</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- New. /O(n)/ plus the cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs | not (p x) . </span>
<span class='hs-comment'>-- &gt;   takeWhileEnd p (xs ++ [x]) == []</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x . </span>
<span class='hs-comment'>-- &gt;   takeWhileEnd p (xs ++ [x]) == takeWhileEnd p xs ++ [x]</span>
<span class='hs-definition'>takeWhileEnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>takeWhileEnd</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>spanEnd</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'dropWhileEnd' function drops the largest suffix of a list</span>
<span class='hs-comment'>-- in which the given predicate holds for all elements.  Some examples:</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; dropWhileEnd isSpace "foo\n" == "foo"</span>
<span class='hs-comment'>-- &gt; dropWhileEnd isSpace "foo bar" == "foo bar"</span>
<span class='hs-comment'>-- &gt; dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs | not (p x) . </span>
<span class='hs-comment'>-- &gt;   dropWhileEnd p (xs ++ [x]) == xs ++ [x]</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x . </span>
<span class='hs-comment'>-- &gt;   dropWhileEnd p (xs ++ [x]) == dropWhileEnd p xs</span>
<span class='hs-definition'>dropWhileEnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>dropWhileEnd</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>spanEnd</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | 'span', applied to a predicate @p@ and a list @xs@,</span>
<span class='hs-comment'>-- returns a tuple where the first element is the longest prefix</span>
<span class='hs-comment'>-- of @xs@ whose elements satisfy @p@ and</span>
<span class='hs-comment'>-- the second element is the remainder of the list.  Some</span>
<span class='hs-comment'>-- examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])</span>
<span class='hs-comment'>-- &gt; span (&lt; 9) [1,2,3] == ([1,2,3],[])</span>
<span class='hs-comment'>-- &gt; span (&lt; 0) [1,2,3] == ([],[1,2,3])</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- @'span' p xs@ is equivalent to @('takeWhile' p xs,</span>
<span class='hs-comment'>-- 'dropWhile' p xs)@. /O(n)/ plus the cost of evaluating</span>
<span class='hs-comment'>-- @p@. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . span p xs == (takeWhile p xs, dropWhile p xs)</span>
<span class='hs-definition'>span</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>span</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'break', applied to a predicate @p@ and a list @xs@,</span>
<span class='hs-comment'>-- returns a tuple where the first element is the longest prefix</span>
<span class='hs-comment'>-- of @xs@ whose elements that /do not</span>
<span class='hs-comment'>-- satisfy/ @p@ and the second element is the remainder of the</span>
<span class='hs-comment'>-- list. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])</span>
<span class='hs-comment'>-- &gt; break (&lt; 9) [1,2,3] == ([],[1,2,3])</span>
<span class='hs-comment'>-- &gt; break (&gt; 9) [1,2,3] == ([1,2,3],[])</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- 'break' @p@ is equivalent to @'span' ('not' . p)@. </span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . break p xs == span (not p) xs</span>
<span class='hs-definition'>break</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>break</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>span</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'stripPrefix' function drops the given prefix from a list.</span>
<span class='hs-comment'>-- It returns 'Just' the suffix of the list after the given prefix</span>
<span class='hs-comment'>-- if the prefix matches, and 'Nothing' otherwise.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>--</span>
<span class='hs-comment'>-- &gt; stripPrefix "foo" "foobar" == Just "bar"</span>
<span class='hs-comment'>-- &gt; stripPrefix "foo" "foo" == Just ""</span>
<span class='hs-comment'>-- &gt; stripPrefix "foo" "barfoo" == Nothing</span>
<span class='hs-comment'>-- &gt; stripPrefix "foo" "barfoobaz" == Nothing</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ where /n/ is the length of the prefix. This is a</span>
<span class='hs-comment'>-- special case of 'stripPrefixBy' with @(==)@ as the equality</span>
<span class='hs-comment'>-- predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall ps xs . stripPrefix ps xs == stripPrefixBy (==) ps xs</span>
<span class='hs-definition'>stripPrefix</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>stripPrefix</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripPrefixBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'stripPrefixBy' function drops the given prefix from a list.</span>
<span class='hs-comment'>-- It returns 'Just' the suffix of the list after the given prefix</span>
<span class='hs-comment'>-- if the prefix matches, and 'Nothing' otherwise. A user-supplied</span>
<span class='hs-comment'>-- predicate is used for testing element equality.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ where /n/ is the length of the prefix.  Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall eq xs . stripPrefixBy eq [] xs == Just xs</span>
<span class='hs-comment'>-- &gt; forall eq . stripPrefixBy eq [] [] == Just []</span>
<span class='hs-comment'>-- &gt; forall eq ps | not (null ps) . </span>
<span class='hs-comment'>-- &gt;   stripPrefixBy eq ps [] == Nothing</span>
<span class='hs-comment'>-- &gt; forall eq p ps x xs | not (null ps) &amp;&amp; not (null xs) &amp;&amp; not (eq p x) . </span>
<span class='hs-comment'>-- &gt;   stripPrefixBy eq (p : ps) (x : xs) == Nothing</span>
<span class='hs-comment'>-- &gt; forall eq p ps x xs | not (null ps) &amp;&amp; not (null xs) &amp;&amp; eq p x . </span>
<span class='hs-comment'>-- &gt;   stripPrefixBy eq (p : ps) (x : xs) == stripPrefixBy eq ps xs</span>
<span class='hs-definition'>stripPrefixBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>stripPrefixBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ys</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>

<span class='hs-comment'>-- | The 'stripSuffix' function drops the given suffix from a list.</span>
<span class='hs-comment'>-- It returns 'Just' the prefix of the list before the given suffix</span>
<span class='hs-comment'>-- if the suffix matches, and 'Nothing' otherwise. 'stripSuffix' is</span>
<span class='hs-comment'>-- a special case of 'stripBy' using '(==)' as the equality predicate.</span>
<span class='hs-comment'>-- Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall ss xs . stripSuffix ss xs == stripSuffixBy (==) ss xs</span>
<span class='hs-definition'>stripSuffix</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>stripSuffix</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripSuffixBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'stripSuffixBy' function drops the given suffix from a list.</span>
<span class='hs-comment'>-- It returns 'Just' the prefix of the list before the given suffix</span>
<span class='hs-comment'>-- if the suffix matches, and 'Nothing' otherwise. A user-supplied</span>
<span class='hs-comment'>-- predicate is used for testing element equality.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- New. /O(m n)/ where /m/ is the length of the prefix and /n/ is the</span>
<span class='hs-comment'>-- length of the list..  Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall eq xs . stripSuffixBy eq [] xs == Just xs</span>
<span class='hs-comment'>-- &gt; forall eq . stripSuffixBy eq [] [] == Just []</span>
<span class='hs-comment'>-- &gt; forall eq ss | not (null ss) . </span>
<span class='hs-comment'>-- &gt;   stripSuffixBy eq ss [] == Nothing</span>
<span class='hs-comment'>-- &gt; forall eq s ss x xs | not (null ps) &amp;&amp; not (null xs) &amp;&amp; not (eq s x) . </span>
<span class='hs-comment'>-- &gt;   stripSuffixBy eq (ss ++ [s]) (xs ++ [x]) == Nothing</span>
<span class='hs-comment'>-- &gt; forall eq s ss x xs | not (null ss) &amp;&amp; not (null ss) &amp;&amp; eq s x . </span>
<span class='hs-comment'>-- &gt;   stripSuffixBy eq (ss ++ [s]) (xs ++ [x]) == stripSuffixBy eq ps xs</span>
<span class='hs-definition'>stripSuffixBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>stripSuffixBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>lookupBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>`equals`</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>splits</span> <span class='hs-varid'>xs0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>xs</span> <span class='hs-varop'>`equals`</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>case</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>of</span>
        <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
      <span class='hs-keyword'>where</span>
        <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
        <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>ok</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ys'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ok</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>ys'</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'group' function takes a list and returns a</span>
<span class='hs-comment'>-- partition of that list such that elements @x1@ and @x2@</span>
<span class='hs-comment'>-- share a partition if and only if they are adjacent and</span>
<span class='hs-comment'>-- equal. Thus, each sublist in the resulting list of lists</span>
<span class='hs-comment'>-- contains only equal elements, and the concatenation of</span>
<span class='hs-comment'>-- the result is the original list.  For example:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This function is a special case of 'groupBy' using the '(==)' </span>
<span class='hs-comment'>-- predicate. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs . group xs == groupBy (==) xs</span>
<span class='hs-definition'>group</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>group</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>groupBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs0</span>

<span class='hs-comment'>-- | The 'groupBy' function takes a list and returns a</span>
<span class='hs-comment'>-- partition of that list such that elements @x1@ and @x2@</span>
<span class='hs-comment'>-- share a partition if and only if they are adjacent and</span>
<span class='hs-comment'>-- they are equal according to the given equality</span>
<span class='hs-comment'>-- test. Thus, each sublist in the resulting list of lists</span>
<span class='hs-comment'>-- contains only equal elements, and the concatenation of</span>
<span class='hs-comment'>-- the result is the original list.  For example:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; groupBy (==) "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . groupBy p [] == []</span>
<span class='hs-comment'>-- &gt; forall p x xs xss | groupBy p xs == [] : xss .</span>
<span class='hs-comment'>-- &gt;   groupBy p (x : xs) == [x] : xss</span>
<span class='hs-comment'>-- &gt; forall p x xs x1 xs1 xss | </span>
<span class='hs-comment'>-- &gt;  p x x1 &amp;&amp; groupBy p xs == ((x1 : xs1) : xss) .</span>
<span class='hs-comment'>-- &gt;   groupBy p (x : xs) == ((x : x1 : xs1) : xss)</span>
<span class='hs-comment'>-- &gt; forall p x xs x1 xs1 xss | </span>
<span class='hs-comment'>-- &gt;  not (p x x1) &amp;&amp; groupBy p xs == ((x1 : xs1) : xss) .</span>
<span class='hs-comment'>-- &gt;   groupBy p (x : xs) == [x] : (x1 : xs1) : xss</span>
<span class='hs-definition'>groupBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>groupBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>span</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>in</span>
      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs'</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- Adapted from teh standard library.</span>

<span class='hs-comment'>-- | The 'inits' function returns all initial segments of the argument,</span>
<span class='hs-comment'>-- shortest first.  For example:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; inits "abc" == ["","a","ab","abc"]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n^2)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; inits [] == [[]]</span>
<span class='hs-comment'>-- &gt; forall x xs . inits (x : xs) == map (x :) (inits xs)</span>
<span class='hs-definition'>inits</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>inits</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-conop'>:</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>

<span class='hs-comment'>-- | The 'tails' function returns all final segments of the argument,</span>
<span class='hs-comment'>-- longest first.  For example,</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; tails "abc" == ["abc", "bc", "c",""]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n^2)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; tails [] == [[]]</span>
<span class='hs-comment'>-- &gt; forall x xs . tails (xs ++ [x]) == map (++ [x]) (tails xs) ++ [[]]</span>
<span class='hs-definition'>tails</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>tails</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>as</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span>
    <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"tails: internal error: fell off end"</span>

<span class='hs-comment'>-- | The 'isPrefixOf' function takes two lists and returns</span>
<span class='hs-comment'>-- 'True' iff the first list is a prefix of the second.</span>
<span class='hs-comment'>-- This is a special case of 'isPrefixOfBy' with '(==)' as</span>
<span class='hs-comment'>-- the equality predicate.  /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall ps xs . isPrefixOf ps xs == isPrefixOfBy (==) ps xs</span>
<span class='hs-definition'>isPrefixOf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>isPrefixOf</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isPrefixOfBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | The 'isPrefixOfBy' function takes two lists and returns</span>
<span class='hs-comment'>-- 'True' iff the first list is a prefix of the second</span>
<span class='hs-comment'>-- according to the given equality predicate.</span>
<span class='hs-comment'>-- New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p ps xs ys | stripPrefixBy p ps xs == Just ys . </span>
<span class='hs-comment'>-- &gt;   isPrefixBy p ps xs == True</span>
<span class='hs-comment'>-- &gt; forall p ps xs | stripPrefixBy p ps xs == Nothing . </span>
<span class='hs-comment'>-- &gt;   isPrefixBy p ps xs == False</span>
<span class='hs-definition'>isPrefixOfBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>isPrefixOfBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>case</span> <span class='hs-varid'>stripPrefixBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>

<span class='hs-comment'>-- | The 'isSuffixOf' function takes two lists and returns</span>
<span class='hs-comment'>-- 'True' iff the first list is a suffix of the second.</span>
<span class='hs-comment'>-- This is a special case of 'isSuffixOfBy' with '(==)' as</span>
<span class='hs-comment'>-- the equality predicate.  /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall ss xs . isSuffixOf ss xs == isSuffixOfBy (==) ss xs</span>
<span class='hs-definition'>isSuffixOf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>isSuffixOf</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isSuffixOfBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | The 'isSuffixOfBy' function takes two lists and returns</span>
<span class='hs-comment'>-- 'True' iff the first list is a suffix of the second</span>
<span class='hs-comment'>-- according to the given equality predicate.</span>
<span class='hs-comment'>-- New. /O(n)/ plus the cost of</span>
<span class='hs-comment'>-- evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p ss xs ys | stripSuffixBy p ss xs == Just ys . </span>
<span class='hs-comment'>-- &gt;   isSuffixOfBy p ss xs == True</span>
<span class='hs-comment'>-- &gt; forall p ss xs | stripSuffixBy p ss xs == Nothing . </span>
<span class='hs-comment'>-- &gt;   isSuffixOfBy p ss xs == False</span>
<span class='hs-definition'>isSuffixOfBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>isSuffixOfBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>case</span> <span class='hs-varid'>stripSuffixBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>

<span class='hs-comment'>-- XXX Quadratic, but I doubt the standard library</span>
<span class='hs-comment'>-- is full of Boyer-Moore code.</span>

<span class='hs-comment'>-- | The 'isInfixOf' function takes two lists and returns 'True'</span>
<span class='hs-comment'>-- iff the first list is contained, wholly and intact,</span>
<span class='hs-comment'>-- anywhere within the second. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt;isInfixOf "Haskell" "I really like Haskell." == True</span>
<span class='hs-comment'>-- &gt;isInfixOf "Ial" "I really like Haskell." == False</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This is a special case of the 'isInfixOfBy' function </span>
<span class='hs-comment'>-- with '(==)' as the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs xs1 . isInfixOf xs ys == isInfixOfBy (==) xs ys</span>
<span class='hs-definition'>isInfixOf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>isInfixOf</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isInfixOfBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | The 'isInfixOfBy' function takes two lists and returns</span>
<span class='hs-comment'>-- 'True' iff the first list is contained, wholly and</span>
<span class='hs-comment'>-- intact, anywhere within the second, as measured by the</span>
<span class='hs-comment'>-- given equality predicate. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt;isInfixOfBy (==) "Haskell" "I really like Haskell." == True</span>
<span class='hs-comment'>-- &gt;isInfixOfBy (==) "Ial" "I really like Haskell." == False</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- New. /O(m n)/ where /m/ is the length of the prefix and /n/ the</span>
<span class='hs-comment'>-- length of the list searched, plus the cost of</span>
<span class='hs-comment'>-- evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs xs1 xs2 xs3 | xs == xs1 ++ xs2 ++ xs3 .</span>
<span class='hs-comment'>-- &gt;   isInfixOfBy p xs2 xs == True</span>
<span class='hs-comment'>-- &gt; forall p xs . nexists xs1 xs2 xs3 | xs == xs1 ++ xs2 ++ xs3 .</span>
<span class='hs-comment'>-- &gt;   isInfixOfBy p xs2 xs == False</span>
<span class='hs-definition'>isInfixOfBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>isInfixOfBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>isPrefixOfBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tails</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'elem' is the list membership predicate. Given an</span>
<span class='hs-comment'>-- element and a list, return 'True' if the element is found</span>
<span class='hs-comment'>-- in the list. Return 'False' otherwise. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . elem x xs == elemBy (==) x xs</span>
<span class='hs-definition'>elem</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>elem</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>elemBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- There should be an elemBy. Yes, it's just "any", but</span>
<span class='hs-comment'>-- still...</span>

<span class='hs-comment'>-- | 'elemBy' is the list membership predicate. Given an</span>
<span class='hs-comment'>-- element and a list, return 'True' if the element is found</span>
<span class='hs-comment'>-- in the list, according to the given equality</span>
<span class='hs-comment'>-- function. Return 'False' otherwise. New. /O(n)/ plus</span>
<span class='hs-comment'>-- the cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs . elemBy p x xs == any (p x) xs</span>
<span class='hs-definition'>elemBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>elemBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>x0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>eq</span> <span class='hs-varid'>x0</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- OTOH, why is there a notElem? Did we really need that?</span>

<span class='hs-comment'>-- | 'elem' is the list non-membership predicate. Given an</span>
<span class='hs-comment'>-- element and a list, return 'False' if the element is found</span>
<span class='hs-comment'>-- in the list. Return 'True' otherwise. New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . notElem x xs == not (elem x xs)</span>
<span class='hs-definition'>notElem</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>notElem</span> <span class='hs-varid'>x0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>elem</span> <span class='hs-varid'>x0</span>

<span class='hs-comment'>-- | 'notElemBy' is the list non-membership predicate. Given</span>
<span class='hs-comment'>-- an element and a list, return 'False' if the element is</span>
<span class='hs-comment'>-- found in the list, according to the given equality</span>
<span class='hs-comment'>-- function. Return 'True' otherwise. New. /O(n)/ plus the</span>
<span class='hs-comment'>-- cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs . notElemBy p x xs == not (elemBy p x xs)</span>
<span class='hs-definition'>notElemBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class='hs-definition'>notElemBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>elemBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x0</span>
  
<span class='hs-comment'>-- | @'lookupBy' p key assocs@ looks up @key@ in</span>
<span class='hs-comment'>-- \"association list\" @assocs@ using the specified</span>
<span class='hs-comment'>-- equality predicate @p@. This is a special case of</span>
<span class='hs-comment'>-- 'lookupBy' with '(==)' as the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall k0 xs . lookup k0 xs == lookupBy (==) k0 xs</span>
<span class='hs-definition'>lookup</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>b</span>
<span class='hs-definition'>lookup</span> <span class='hs-varid'>x0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>lookupBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-varid'>x0</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | @'lookupBy' p key assocs@ looks up @key@ in</span>
<span class='hs-comment'>-- \"association list\" @assocs@ using the specified</span>
<span class='hs-comment'>-- equality predicate @p@. New. /O(n)/ plus the cost of</span>
<span class='hs-comment'>-- evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p k0 . lookupBy p k0 [] == Nothing</span>
<span class='hs-comment'>-- &gt; forall p k0 a xs .</span>
<span class='hs-comment'>-- &gt;   lookupBy p k0 ((k0, a) : xs) == Just a</span>
<span class='hs-comment'>-- &gt; forall p k0 k a xs | k /= k0 .</span>
<span class='hs-comment'>-- &gt;   lookupBy p k0 ((k, a) : xs) == lookupBy p k0 xs</span>
<span class='hs-definition'>lookupBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>b</span>
<span class='hs-definition'>lookupBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>xk</span><span class='hs-layout'>,</span> <span class='hs-varid'>xv</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xk</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>xv</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>

<span class='hs-comment'>-- | The 'find' function takes a predicate and a list and</span>
<span class='hs-comment'>-- returns the 'Just' the first element in the list for</span>
<span class='hs-comment'>-- which the predicate hold; 'find' returns 'Nothing' if</span>
<span class='hs-comment'>-- there is no element for which the predicate</span>
<span class='hs-comment'>-- holds. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . find p [] == Nothing</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x == True . find p (x : xs) == Just x</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x == False . find p (x : xs) == find p xs</span>
<span class='hs-definition'>find</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>find</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>

<span class='hs-comment'>-- | 'filter', applied to a predicate and a list, returns the list of</span>
<span class='hs-comment'>-- those elements that satisfy the predicate (in order). /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . filter p [] == []</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x == True . filter p (x : xs) == x : filter p xs</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x == False . filter p (x : xs) == filter p xs</span>
<span class='hs-definition'>filter</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>filter</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>partition</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'partition' function takes a predicate and a list</span>
<span class='hs-comment'>-- and returns the pair of lists of elements which do and do</span>
<span class='hs-comment'>-- not satisfy the predicate, respectively. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . partition p xs == (filter p xs, filter (not . p) xs)</span>
<span class='hs-definition'>partition</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>partition</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | List index (subscript) operator, starting from 0. /O(n)/ where</span>
<span class='hs-comment'>-- /n/ is the right-hand argument. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . (x : xs) !! 0 == x</span>
<span class='hs-comment'>-- &gt; forall n x xs | </span>
<span class='hs-comment'>-- &gt;  n &gt; 0 &amp;&amp; n &lt; length (x : xs) .</span>
<span class='hs-comment'>-- &gt;   (x : xs) !! n == xs !! (n - 1)</span>
<span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class='hs-keyword'>_</span> <span class='hs-varop'>!!</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>error</span> <span class='hs-str'>"!!: negative index"</span>
<span class='hs-definition'>xs</span> <span class='hs-varop'>!!</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-keyword'>case</span> <span class='hs-varid'>lookup</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>zip</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span>
    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"!!: index too large"</span>

<span class='hs-comment'>-- These elem and find functions mostly come from the standard library.</span>

<span class='hs-comment'>-- | The 'elemIndex' function returns the index of the first element</span>
<span class='hs-comment'>-- in the given list which is equal (by '==') to the query element,</span>
<span class='hs-comment'>-- or 'Nothing' if there is no such element. This is a special</span>
<span class='hs-comment'>-- case of 'elemIndexBy'. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall x xs . elemIndex x xs == elemIndexBy (==) x xs</span>
<span class='hs-definition'>elemIndex</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>elemIndex</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>elemIndexBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'elemIndexBy' function returns the index of the</span>
<span class='hs-comment'>-- first element in the given list which is equal (by the</span>
<span class='hs-comment'>-- given predicate) to the query element, or 'Nothing' if</span>
<span class='hs-comment'>-- there is no such element. This is a special case of</span>
<span class='hs-comment'>-- 'findIndex'. New. /O(n)/ plus the cost of evaluating the</span>
<span class='hs-comment'>-- predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall p x xs . elemIndexBy p x xs == findIndex (p x) xs</span>
<span class='hs-definition'>elemIndexBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>elemIndexBy</span> <span class='hs-varid'>eq</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findIndex</span> <span class='hs-layout'>(</span><span class='hs-varid'>eq</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'elemIndices' function extends 'elemIndex', by</span>
<span class='hs-comment'>-- returning the indices of all elements equal (by ==) to</span>
<span class='hs-comment'>-- the query element, in ascending order. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . elemIndices x xs == elemIndicesBy (==) x xs</span>
<span class='hs-definition'>elemIndices</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>elemIndices</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>elemIndicesBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'elemIndicesBy' function extends 'findIndices', by</span>
<span class='hs-comment'>-- returning the indices of all elements equal (by the given</span>
<span class='hs-comment'>-- equality function) to the query element, in ascending</span>
<span class='hs-comment'>-- order. New. /O(n)/ plus the cost of evaluating the</span>
<span class='hs-comment'>-- predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x xs . elemIndicesBy p x xs == findIndicesBy (p x) xs</span>
<span class='hs-definition'>elemIndicesBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>elemIndicesBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findIndices</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'findIndex' function takes a predicate and a list and returns</span>
<span class='hs-comment'>-- the index of the first element in the list satisfying the predicate,</span>
<span class='hs-comment'>-- or 'Nothing' if there is no such element. It is a special</span>
<span class='hs-comment'>-- case of 'findIndex' which returns just the first index. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs | findIndices p xs == [] . </span>
<span class='hs-comment'>-- &gt;   findIndex p xs == Nothing</span>
<span class='hs-comment'>-- &gt; forall p xs y ys | findIndices p xs == (y : ys) . </span>
<span class='hs-comment'>-- &gt;   findIndex p xs == Just y</span>
<span class='hs-definition'>findIndex</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>findIndex</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-keyword'>case</span> <span class='hs-varid'>findIndices</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
    <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>

<span class='hs-comment'>-- | The 'findIndices' function extends 'findIndex', by returning the</span>
<span class='hs-comment'>-- indices of all elements satisfying the predicate, in ascending order.</span>
<span class='hs-definition'>findIndices</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>findIndices</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zip</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- This idea comes from the standard library.</span>

<span class='hs-comment'>-- | The 'zip'function takes two lists and returns a list of</span>
<span class='hs-comment'>-- corresponding pairs. If one input list is short, excess</span>
<span class='hs-comment'>-- elements of the longer list are discarded. 'zip' is a </span>
<span class='hs-comment'>-- special case of 'zipWith' with the tupling function @(,)@ </span>
<span class='hs-comment'>-- as the operator. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall xs . zip [] xs == []</span>
<span class='hs-comment'>-- forall xs . zip xs [] == []</span>
<span class='hs-comment'>-- forall x xs y ys . zip (x : xs) (y : ys) == (x, y) : zip xs ys</span>
<span class='hs-definition'>zip</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zip</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>zipWith</span> <span class='hs-conid'>(,)</span>

<span class='hs-comment'>-- | 'zip' from 3 lists to 3-tuples.</span>
<span class='hs-definition'>zip3</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zip3</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>zipWith3</span> <span class='hs-conid'>(,,)</span>

<span class='hs-comment'>-- | 'zip' from 4 lists to 4-tuples.</span>
<span class='hs-definition'>zip4</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zip4</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>zipWith4</span> <span class='hs-conid'>(,,,)</span>

<span class='hs-comment'>-- | 'zip' from 5 lists to 5-tuples.</span>
<span class='hs-definition'>zip5</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zip5</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>zipWith5</span> <span class='hs-conid'>(,,,,)</span>

<span class='hs-comment'>-- | 'zip' from 6 lists to 6-tuples.</span>
<span class='hs-definition'>zip6</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zip6</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>zipWith6</span> <span class='hs-conid'>(,,,,,)</span>

<span class='hs-comment'>-- | 'zip' from 7 lists to 7-tuples.</span>
<span class='hs-definition'>zip7</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>g</span><span class='hs-keyglyph'>]</span> 
     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zip7</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>zipWith7</span> <span class='hs-conid'>(,,,,,,)</span>

<span class='hs-comment'>-- I don't believe anyone uses higher-arity zips, but I feel constrained</span>
<span class='hs-comment'>-- by the standard library.</span>


<span class='hs-comment'>-- | The 'zipWith' function generalises 'zip' by zipping</span>
<span class='hs-comment'>-- with the function given as the first argument, instead of</span>
<span class='hs-comment'>-- a tupling function. For example, @'zipWith' (+)@ is</span>
<span class='hs-comment'>-- applied to two lists to produce the list of corresponding</span>
<span class='hs-comment'>-- sums. /O(n)/. Laws: </span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall f xs . zipWith f [] xs == []</span>
<span class='hs-comment'>-- forall f xs . zipWith f xs [] == []</span>
<span class='hs-comment'>-- forall f x xs y ys . zipWith (x : xs) (y : ys) == f x y : zipWith xs ys</span>
<span class='hs-definition'>zipWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zipWith</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs2</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>l2</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l2s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>l1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>l2s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>g</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>

<span class='hs-comment'>-- | 'zipWith' with 3 lists and a 3-argument function.</span>
<span class='hs-definition'>zipWith3</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zipWith3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'zipWith' with 4 lists and a 4-argument function.</span>
<span class='hs-definition'>zipWith4</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zipWith4</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'zipWith' with 5 lists and a 5-argument function.</span>
<span class='hs-definition'>zipWith5</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> 
         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zipWith5</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-varid'>xs4</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith4</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-varid'>xs4</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'zipWith' with 6 lists and a 6-argument function.</span>
<span class='hs-definition'>zipWith6</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> 
         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>g</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zipWith6</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-varid'>xs4</span> <span class='hs-varid'>xs5</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith5</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-varid'>xs4</span> <span class='hs-varid'>xs5</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | 'zipWith' with 7 lists and a 7-argument function.</span>
<span class='hs-definition'>zipWith7</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>h</span><span class='hs-layout'>)</span> 
         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>g</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>h</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>zipWith7</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-varid'>xs4</span> <span class='hs-varid'>xs5</span> <span class='hs-varid'>xs6</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith6</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-varid'>xs3</span> <span class='hs-varid'>xs4</span> <span class='hs-varid'>xs5</span> <span class='hs-varid'>xs6</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'unzip' function transforms a list of pairs into a</span>
<span class='hs-comment'>-- list of first components and a list of second</span>
<span class='hs-comment'>-- components. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; unzip [] == ([], [])</span>
<span class='hs-comment'>-- &gt; forall a b xs as bs | (as, bs) == unzip xs . </span>
<span class='hs-comment'>-- &gt;   unzip ((a, b) : xs) == (a : as, b : bs)</span>
<span class='hs-definition'>unzip</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>unzip</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Unzip a 3-tuple into 3 lists.</span>
<span class='hs-definition'>unzip3</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>unzip3</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Unzip a 4-tuple into 4 lists.</span>
<span class='hs-definition'>unzip4</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>unzip4</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Unzip a 5-tuple into 5 lists.</span>
<span class='hs-definition'>unzip5</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>unzip5</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>es</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
      <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span> <span class='hs-conop'>:</span> <span class='hs-varid'>es</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Unzip a 6-tuple into 6 lists.</span>
<span class='hs-definition'>unzip6</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>unzip6</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f0</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f0</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>es</span><span class='hs-layout'>,</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
      <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span> <span class='hs-conop'>:</span> <span class='hs-varid'>es</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-conop'>:</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Unzip a 7-tuple into 7 lists.</span>
<span class='hs-definition'>unzip7</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>g</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>unzip7</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f0</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>    
    <span class='hs-varid'>f0</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>es</span><span class='hs-layout'>,</span> <span class='hs-varid'>fs</span><span class='hs-layout'>,</span> <span class='hs-varid'>gs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
      <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span> <span class='hs-conop'>:</span> <span class='hs-varid'>es</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-conop'>:</span> <span class='hs-varid'>fs</span><span class='hs-layout'>,</span> <span class='hs-varid'>g</span> <span class='hs-conop'>:</span> <span class='hs-varid'>gs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'lines' function breaks a string up into a list of</span>
<span class='hs-comment'>-- strings at newline characters. A trailing newline</span>
<span class='hs-comment'>-- character will not cause an empty string at the end of</span>
<span class='hs-comment'>-- the list, unless the input string consists entirely of</span>
<span class='hs-comment'>-- newlines. The resulting strings do not contain newlines.</span>
<span class='hs-comment'>-- /O(n)/. 'lines' is a special case of 'terminate' with </span>
<span class='hs-comment'>-- terminator '\n'. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs . lines xs == terminate '\n' xs</span>
<span class='hs-definition'>lines</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>lines</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>terminate</span> <span class='hs-chr'>'\n'</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'words' function breaks a string up into a list of</span>
<span class='hs-comment'>-- words at sequences of white space (as defined by</span>
<span class='hs-comment'>-- 'Data.Char.isSpace'), discarding any leading or trailing</span>
<span class='hs-comment'>-- whitespace. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs | all isSpace xs . words xs == []</span>
<span class='hs-comment'>-- &gt; forall xs ys z zs </span>
<span class='hs-comment'>-- &gt;  | all isSpace xs &amp;&amp;</span>
<span class='hs-comment'>-- &gt;    all (not . isSpace) ys &amp;&amp;</span>
<span class='hs-comment'>-- &gt;    isSpace z .</span>
<span class='hs-comment'>-- &gt;   words (xs ++ ys ++ (z : zs)) == ys : words (z : zs)</span>
<span class='hs-definition'>words</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>words</span> <span class='hs-varid'>s0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>s0</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>s</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>ws</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span>
        <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>ws'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>break</span> <span class='hs-varid'>isSpace</span> <span class='hs-varid'>ws</span> <span class='hs-keyword'>in</span>
        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>ws'</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span>
        <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ws</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>span</span> <span class='hs-varid'>isSpace</span> <span class='hs-varid'>s</span>

<span class='hs-comment'>-- | The 'unlines' function appends a newline to each</span>
<span class='hs-comment'>-- element of its string list argument and concatenates</span>
<span class='hs-comment'>-- the result. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; unlines [] == ""</span>
<span class='hs-comment'>-- &gt; forall xs xss . </span>
<span class='hs-comment'>-- &gt;   unlines (xs : xss) == concatMap (++ "\n") (xs : xss)</span>
<span class='hs-definition'>unlines</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span>
<span class='hs-definition'>unlines</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>""</span>
<span class='hs-definition'>unlines</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span> <span class='hs-str'>"\n"</span><span class='hs-layout'>)</span> <span class='hs-varid'>xss</span>

<span class='hs-comment'>-- | The 'unwords' function places a space character between each</span>
<span class='hs-comment'>-- element of its string list argument and concatenates</span>
<span class='hs-comment'>-- the result. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xss . unwords xss == intercalate " " xss</span>
<span class='hs-definition'>unwords</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span>
<span class='hs-definition'>unwords</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>intercalate</span> <span class='hs-str'>" "</span> <span class='hs-varid'>xss</span>

<span class='hs-comment'>-- | The 'nub' function removes duplicate elements from a</span>
<span class='hs-comment'>-- list.  In particular, it keeps only the first occurrence</span>
<span class='hs-comment'>-- of each element.  (The name 'nub' means \"essence\".)  It</span>
<span class='hs-comment'>-- is a special case of 'nubBy' with @(==)@ as the equality</span>
<span class='hs-comment'>-- test. /O(n^2)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs . nub xs == nubBy (==) xs</span>
<span class='hs-definition'>nub</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>nub</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nubBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'nub' function removes duplicate elements from a</span>
<span class='hs-comment'>-- list.  In particular, it keeps only the first occurrence</span>
<span class='hs-comment'>-- of each element, as judged by the given equality predicate.  </span>
<span class='hs-comment'>-- (The name 'nub' means \"essence\".)</span>
<span class='hs-comment'>-- /O(n^2)/ plus the cost of evaluating the predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p . nubBy p [] == []</span>
<span class='hs-comment'>-- &gt; forall p x xs . nubBy p (x : xs) == x : filter (not . p) (nubBy p xs)</span>
<span class='hs-definition'>nubBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>elemBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'delete' function deletes the first occurrence, if</span>
<span class='hs-comment'>-- any, of a given element from a given list. It is a</span>
<span class='hs-comment'>-- special case of 'deleteBy' with @(==)@ as the equality</span>
<span class='hs-comment'>-- test. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x xs . delete x xs == deleteBy (==) x xs</span>
<span class='hs-definition'>delete</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>delete</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deleteBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'deleteBy' function deletes the first occurrence, if</span>
<span class='hs-comment'>-- any, of a given element from a given list, using</span>
<span class='hs-comment'>-- the supplied equality test. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; delete 'a' "banana" == "bnana"</span>
<span class='hs-comment'>-- &gt; delete 'a' "frog" == "frog"</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p x . deleteBy p x [] == []</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x == True . </span>
<span class='hs-comment'>-- &gt;   deleteBy p x xs == xs</span>
<span class='hs-comment'>-- &gt; forall p x xs | p x == False . </span>
<span class='hs-comment'>-- &gt;   deleteBy p x xs == x : deleteBy p xs</span>
<span class='hs-definition'>deleteBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>deleteBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x0</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>break</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varid'>x0</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs0</span> <span class='hs-keyword'>in</span>
  <span class='hs-varid'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>safeTail</span> <span class='hs-varid'>ys</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>safeTail</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
    <span class='hs-varid'>safeTail</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | The '\\' operator is non-associative list difference.</span>
<span class='hs-comment'>-- The result of @xs '\\' ys@ is @xs@ with the first</span>
<span class='hs-comment'>-- occurence (if any) of each element of @ys@ removed. Thus</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; (xs ++ ys) \\ xs == ys</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- The '\\' operator is a special case of the</span>
<span class='hs-comment'>-- 'deleteFirstsBy' function with equality operator</span>
<span class='hs-comment'>-- @(==)@. /O(m n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs ys . xs \\ ys == deleteFirstsBy (==) xs ys</span>
<span class='hs-layout'>(</span><span class='hs-varop'>\\</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>xs</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deleteFirstsBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | The 'deleteFirstsBy' function is non-associative list</span>
<span class='hs-comment'>-- difference under a user-provided equality predicate.  The</span>
<span class='hs-comment'>-- result of @'deleteFirstsBy' xs ys@ is @xs@ with the first</span>
<span class='hs-comment'>-- occurence (if any, as measured by the supplied equality</span>
<span class='hs-comment'>-- predicate) of each element of @ys@ removed. Thus, for any</span>
<span class='hs-comment'>-- well-formed equality predicate @p@</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; deleteFirstBy p (xs ++ ys) xs == ys</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(m n)/ plus the cost of evaluating the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . deleteFirstsBy p xs [] == xs</span>
<span class='hs-comment'>-- &gt; forall p xs (y : ys) . deleteFirstsBy p (deleteBy p y xs) ys</span>
<span class='hs-definition'>deleteFirstsBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>deleteFirstsBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varid'>deleteBy</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | The '\\*' operator is like the `\\` operator, except</span>
<span class='hs-comment'>-- that both arguments are made canonical by elimination of</span>
<span class='hs-comment'>-- duplicate elements before differencing. /O(m n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs ys . xs \\* ys == deleteFirstsBy' (==) xs ys</span>
<span class='hs-layout'>(</span><span class='hs-varop'>\\*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>xs</span> <span class='hs-varop'>\\*</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deleteFirstsBy'</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | This variant of 'deleteFirstsBy' makes the result</span>
<span class='hs-comment'>-- canonical on all inputs. /O(m n) + O(m^2) + O(n^2)/ plus</span>
<span class='hs-comment'>-- the cost of evaluating the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs ys . </span>
<span class='hs-comment'>-- &gt;   deleteFirstsBy' p xs ys == deleteFirstsBy p (nub xs) (nub ys)</span>
<span class='hs-definition'>deleteFirstsBy'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>deleteFirstsBy'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>deleteFirstsBy</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'union' function returns the \"list union\" of</span>
<span class='hs-comment'>-- two lists. It is a special case of 'unionBy' with @(==)@</span>
<span class='hs-comment'>-- as the equality predicate. /O(m n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs ys . union xs ys == unionBy (==) xs ys</span>
<span class='hs-definition'>union</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>union</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unionBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'unionBy' function returns the \"list union\" of two lists,</span>
<span class='hs-comment'>-- under the given equality predicate.</span>
<span class='hs-comment'>-- Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; unionBy (==) "dog" "cow" == "dogcw"</span>
<span class='hs-comment'>-- &gt; unionBy (==) "moose" "cow" == "moosecw"</span>
<span class='hs-comment'>-- &gt; unionBy (==) "moose" "woodpecker" == "moosewdpckr"</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(m n) + O(n^2)/ plus the cost of evaluating the </span>
<span class='hs-comment'>-- equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs ys . </span>
<span class='hs-comment'>-- &gt;   unionBy p xs ys == xs ++ deleteFirstsBy p (nubBy p ys) xs</span>
<span class='hs-definition'>unionBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>unionBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>deleteFirstsBy</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'union'' function returns the \"list union\" of</span>
<span class='hs-comment'>-- two lists. It is a special case of 'unionBy'' with @(==)@</span>
<span class='hs-comment'>-- as the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs ys . union' xs ys == unionBy' (==) xs ys</span>
<span class='hs-definition'>union'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>union'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unionBy'</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'unionBy'' function returns the \"list union\" of</span>
<span class='hs-comment'>-- two lists, under the given equality predicate, but</span>
<span class='hs-comment'>-- \"canonicalized\" such that each element appears only</span>
<span class='hs-comment'>-- once.  /O(m n) + O(m^2) + O(n^2)/ plus the cost of</span>
<span class='hs-comment'>-- evaluating the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs ys . </span>
<span class='hs-comment'>-- &gt;   unionBy' p xs ys == unionBy p (nubBy p xs) (nubBy p ys)</span>
<span class='hs-definition'>unionBy'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>unionBy'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unionBy</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'intersect' function returns the \"list</span>
<span class='hs-comment'>-- intersection\" of two lists. It is a special case of</span>
<span class='hs-comment'>-- 'intersectBy' with @(==)@ as the equality predicate. </span>
<span class='hs-comment'>-- /O(m n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs ys . intersect xs ys == intersectBy (==) xs ys</span>
<span class='hs-definition'>intersect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>intersect</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>intersectBy</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'intersectBy' function returns the \"list</span>
<span class='hs-comment'>-- intersection\" of two lists, under the given equality</span>
<span class='hs-comment'>-- predicate. If the first list contains duplicates, so</span>
<span class='hs-comment'>-- will the result. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; intersectBy (==) [1, 2, 3, 4] [2, 4, 6, 8] == [2, 4]</span>
<span class='hs-comment'>-- &gt; intersectBy (==) [1, 2, 2, 3, 4] [6, 4, 4, 2] == [2, 2, 4]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(m n)/ plus the cost of evaluating the </span>
<span class='hs-comment'>-- equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs ys . </span>
<span class='hs-comment'>-- &gt;   intersectBy p xs ys == filter (\x -&gt; elemBy f x ys) xs</span>
<span class='hs-definition'>intersectBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>intersectBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>elemBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>

<span class='hs-comment'>-- | The 'intersect'' function returns the \"list</span>
<span class='hs-comment'>-- intersection\" of two lists, but with all duplicates</span>
<span class='hs-comment'>-- removed first. It is a special case of 'intersectBy''</span>
<span class='hs-comment'>-- with @(==)@ as the equality predicate.  </span>
<span class='hs-comment'>-- /O(m n) + O(m^2) + O(n^2)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall xs ys . intersect xs ys == intersectBy (==) xs ys</span>
<span class='hs-definition'>intersect'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>intersect'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>intersectBy'</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | The 'intersectBy'' function returns the \"list</span>
<span class='hs-comment'>-- intersection\" of two lists, under the given equality</span>
<span class='hs-comment'>-- predicate, but \"canonicalized\" such that each element</span>
<span class='hs-comment'>-- appears only once.  /O(m n) + O(m^2) + O(n^2)/ plus the</span>
<span class='hs-comment'>-- cost of evaluating the equality predicate. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs ys . </span>
<span class='hs-comment'>-- &gt;   intersectBy' p xs ys == intersectBy p (nubBy p xs) ys</span>
<span class='hs-definition'>intersectBy'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>intersectBy'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>intersectBy</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span> <span class='hs-varid'>p</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span>

<span class='hs-comment'>-- | Given two (presumptively) ordered lists, return the</span>
<span class='hs-comment'>-- ordered merge of the lists, with ties broken to the</span>
<span class='hs-comment'>-- left. This is a special case of 'mergeBy' that uses</span>
<span class='hs-comment'>-- 'compare' as the comparison function.  </span>
<span class='hs-comment'>-- New. /O(m + n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- forall xs ys . merge xs ys == mergeBy compare xs ys</span>
<span class='hs-definition'>merge</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>merge</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mergeBy</span> <span class='hs-varid'>compare</span>

<span class='hs-comment'>-- | Given two (presumptively) ordered lists and a</span>
<span class='hs-comment'>-- comparison function, return the ordered merge of the</span>
<span class='hs-comment'>-- lists, with ties broken to the left.  </span>
<span class='hs-comment'>-- New. /O(m + n)/ plus the cost of evaluating the comparison</span>
<span class='hs-comment'>-- function. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall p xs . mergeBy p [] xs == xs</span>
<span class='hs-comment'>-- &gt; forall p xs . mergeBy p xs [] == xs</span>
<span class='hs-comment'>-- &gt; forall p x xs y ys | p x y /= GT . </span>
<span class='hs-comment'>-- &gt;   mergeBy p (x : xs) (y : ys) == x : mergeBy p xs (y : ys)</span>
<span class='hs-comment'>-- &gt; forall p x xs y ys | p x y == GT . </span>
<span class='hs-comment'>-- &gt;   mergeBy p (x : xs) (y : ys) == y : mergeBy p (x : xs) ys</span>
<span class='hs-definition'>mergeBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>mergeBy</span> <span class='hs-varid'>c</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs2</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>x2</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x2s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x2</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>x2s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x1s</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1s</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x2</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x2s</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x1</span> <span class='hs-varop'>`c`</span> <span class='hs-varid'>x2</span> <span class='hs-varop'>==</span> <span class='hs-conid'>GT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x2</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x2s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x2</span> <span class='hs-conop'>:</span> <span class='hs-varid'>x2s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- XXX Need to write laws for sorts.</span>

<span class='hs-comment'>-- | The 'sort' function implements a stable sorting</span>
<span class='hs-comment'>-- algorithm.  It is a special case of 'sortBy' with</span>
<span class='hs-comment'>-- comparison function 'compare'. Strict. /O(n)/.</span>
<span class='hs-definition'>sort</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>sort</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sortBy</span> <span class='hs-varid'>compare</span>

<span class='hs-comment'>-- This is an O(n log n) merge sort, not nearly as fast as</span>
<span class='hs-comment'>-- the magic sort in the standard library. It unfolds</span>
<span class='hs-comment'>-- nicely, though.</span>

<span class='hs-comment'>-- | The 'sortBy' function implements a stable sorting</span>
<span class='hs-comment'>-- algorithm, given a user-supplied comparator</span>
<span class='hs-comment'>-- function. Strict. /O(n)/.</span>
<span class='hs-definition'>sortBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>sortBy</span> <span class='hs-varid'>c</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>case</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lr</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs0</span><span class='hs-layout'>,</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
    <span class='hs-keyglyph'>[</span><span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span>
    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"sort: internal error: incomplete merge"</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>xss</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-layout'>(</span><span class='hs-varid'>sortStep</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>undefined</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span>
        <span class='hs-comment'>-- Assume a list of sorted inputs. Merge adjacent</span>
        <span class='hs-comment'>-- pairs of lists in the input to produce about half</span>
        <span class='hs-comment'>-- as many sorted lists, each about twice as large.</span>
        <span class='hs-varid'>sortStep</span> <span class='hs-keyglyph'>=</span>
          <span class='hs-varid'>unfoldr</span> <span class='hs-varid'>g</span> <span class='hs-varid'>xss</span>
          <span class='hs-keyword'>where</span>
            <span class='hs-varid'>g</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
            <span class='hs-varid'>g</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span>
              <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
            <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs2</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
              <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>mergeBy</span> <span class='hs-varid'>c</span> <span class='hs-varid'>xs1</span> <span class='hs-varid'>xs2</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>

<span class='hs-comment'>-- | Given a list of 'Ord' values, insert an element @x1@ at the first</span>
<span class='hs-comment'>-- position such that the next element @x2@ is greater than or equal to @x1@.</span>
<span class='hs-comment'>-- This function is a special case of 'insertBy' with 'compare' as</span>
<span class='hs-comment'>-- the comparison function. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x0 xs . insert x0 xs == insertBy compare x0 xs</span>
<span class='hs-definition'>insert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>insert</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insertBy</span> <span class='hs-varid'>compare</span>

<span class='hs-comment'>-- | Given a list of 'Ord' values, insert an element @x1@ at the first</span>
<span class='hs-comment'>-- position such that the next element @x2@ is greater than or equal to @x1@,</span>
<span class='hs-comment'>-- using the supplied comparison function. Some examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; insertBy compare 2 [] == [2]</span>
<span class='hs-comment'>-- &gt; insertBy compare 2 [1] == [1, 2]</span>
<span class='hs-comment'>-- &gt; insertBy (comparing fst) (2, 0) [(1, 1), (2, 1), (3, 1)] ==</span>
<span class='hs-comment'>-- &gt;   [(1, 1), (2, 0), (2, 1), (3, 1)]</span>
<span class='hs-comment'>-- &gt; insertBy compare 2 [1, 3, 1, 3] == [1, 2, 3, 1, 3]</span>
<span class='hs-comment'>-- &gt; insertBy compare 2 [3..] == [2..]</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This version of insertBy agrees with the code in the</span>
<span class='hs-comment'>-- standard library, which inserts in the first possible</span>
<span class='hs-comment'>-- location rather than the last. However, it fails to agree</span>
<span class='hs-comment'>-- with the documentation for that library. (This is</span>
<span class='hs-comment'>-- currently bug #7421 in the GHC Trac.)</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- /O(n)/ plus the cost of evaluating the comparison</span>
<span class='hs-comment'>-- function. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall c x0 . insertBy c x0 [] == [x0]</span>
<span class='hs-comment'>-- &gt; forall c x0 x xs | x &gt;= x0 . </span>
<span class='hs-comment'>-- &gt;   insertBy c x0 (x : xs) == x0 : x : xs</span>
<span class='hs-comment'>-- &gt; forall c x0 x xs | x &lt; x0 . </span>
<span class='hs-comment'>-- &gt;   insertBy c x0 (x : xs) == x : insertBy c x0 xs</span>
<span class='hs-definition'>insertBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>insertBy</span> <span class='hs-varid'>c</span> <span class='hs-varid'>t</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>span</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-conid'>GT</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>c</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>in</span>
  <span class='hs-varid'>l</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>++</span> <span class='hs-varid'>r</span>

<span class='hs-comment'>-- | Given a list of 'Ord' values, insert an element @x0@</span>
<span class='hs-comment'>-- into the list at the last position where it is still less</span>
<span class='hs-comment'>-- than or equal to the next element. If no element is</span>
<span class='hs-comment'>-- greater than or equal to @x0@, insert it at the end. This</span>
<span class='hs-comment'>-- function is a special case of 'insertBy'' with 'compare'</span>
<span class='hs-comment'>-- as the comparison function.  /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall x0 xs . insert' x0 xs == insertBy' compare x0 xs</span>
<span class='hs-definition'>insert'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>insert'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insertBy'</span> <span class='hs-varid'>compare</span>

<span class='hs-comment'>-- | Given a list of 'Ord' values, insert an element @x0@</span>
<span class='hs-comment'>-- into the list at the last position where it is still less</span>
<span class='hs-comment'>-- than or equal to the next element. If no elements are</span>
<span class='hs-comment'>-- greater than or equal to @x0@, insert it at the end. Some</span>
<span class='hs-comment'>-- examples:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; insertBy' compare 2 [] == [2]</span>
<span class='hs-comment'>-- &gt; insertBy' compare 2 [1] == [1, 2]</span>
<span class='hs-comment'>-- &gt; insertBy' (comparing fst) (2, 0) [(1, 1), (2, 1), (3, 1)] ==</span>
<span class='hs-comment'>-- &gt;   [(1, 1), (2, 0), (2, 1), (3, 1)]</span>
<span class='hs-comment'>-- &gt; insertBy' compare 2 [1, 3, 1, 3] == [1, 3, 1, 2, 3]</span>
<span class='hs-comment'>-- &gt; insertBy' compare 2 [3..] == _|_</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- This 'insertBy'' actually follows the contract from the</span>
<span class='hs-comment'>-- standard library documentation (inasmuch as that contract</span>
<span class='hs-comment'>-- can be read to specify anything sensible.) It will</span>
<span class='hs-comment'>-- generally be less efficient than 'insertBy', as it</span>
<span class='hs-comment'>-- needs to traverse the whole list to check for further</span>
<span class='hs-comment'>-- insertion points.</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- New. /O(n)/. Laws:</span>
<span class='hs-comment'>-- </span>
<span class='hs-comment'>-- &gt; forall c x0 . insertBy' c x0 [] == [x0]</span>
<span class='hs-comment'>-- &gt; forall c x0 x xs | x &lt;= x0 . </span>
<span class='hs-comment'>-- &gt;   insertBy c x0 (xs ++ [x]) == xs ++ [x, x0]</span>
<span class='hs-comment'>-- &gt; forall c x0 x xs | x &gt; x0 . </span>
<span class='hs-comment'>-- &gt;   insertBy c x0 (xs ++ [x]) == insertBy c x0 xs ++ [x]</span>
<span class='hs-definition'>insertBy'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>insertBy'</span> <span class='hs-varid'>c</span> <span class='hs-varid'>x0</span> <span class='hs-varid'>xs0</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>xs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>xs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spanEnd</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`c`</span> <span class='hs-varid'>x0</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>LT</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs0</span> <span class='hs-keyword'>in</span>
  <span class='hs-varid'>xs1</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x0</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>++</span> <span class='hs-varid'>xs2</span>
</pre></body>
</html>
